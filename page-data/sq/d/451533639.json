{"data":{"allMdx":{"nodes":[{"fields":{"slug":"/placeholder/","title":"This Is a Placeholder File for Mdx"},"frontmatter":{"draft":true},"rawBody":"---\ntitle: This Is a Placeholder File for Mdx\ndraft: true\ntags:\n  - gatsby-theme-primer-wiki-placeholder\n---\n"},{"fields":{"slug":"/","title":"SNUBAYES WIKI"},"frontmatter":{"draft":false},"rawBody":"# SNUBAYES WIKI\n\n## 1 Introduction\n\n서울대학교 통계학과 베이즈연구실 위키\n\n## 2 How to Use\n\n* 적당한 위치에 위키 저장소 clone github - `git clone https://github.com/snubayes/wiki.git`\n* [[docs/how-to/getting-started]]에 간단한 사용법 소개\n* graph view를 통해 각 문서 확인\n* 기본적인 문법은 구글에 \"마크다운 문법\"으로 검색\n\n## 3 주요 문서 목록\n\n* [[lab-main|연구실 관련]]\n* [[statgpu-main|학과서버 관련]]\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[docs/how-to/getting-started]: docs/how-to/getting-started.md \"Getting Started\"\n[lab-main|연구실 관련]: docs/lab/lab-main.md \"베이즈통계 연구실\"\n[statgpu-main|학과서버 관련]: docs/statgpu/statgpu-main.md \"서울대학교 통계학과 학과서버 사용 메뉴얼\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/features/daily-notes/","title":"Daily Notes"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Daily Notes\n---\nDaily notes allow you to quickly create and access notes for today.\n\nTry it out, run the `Foam: Open Daily Note` command.\n\n## Shortcuts and Snippets\n\nYou can quickly open today's daily note by pressing `alt+d`.\nYou can also automatically open today's note via the `Foam › Open Daily Note: On Startup` setting.\n\nYou can also quickly create link to your daily notes, in the configured format, using [snippets](https://code.visualstudio.com/docs/editor/userdefinedsnippets).\n\nType `/today` and press `enter` to link to today's note.\nYou can also write:\n\n| Snippet      | Date          |\n| ------------ | ------------- |\n| `/tomorrow`  | tomorrow      |\n| `/yesterday` | yesterday     |\n| `/monday`    | next monday   |\n| `/+1d`       | tomorrow      |\n| `/-3d`       | 3 days ago    |\n| `/+1w`       | in a week     |\n| `/-1m`       | one month ago |\n| `/+1y`       | in one year   |\n\nYou get the idea ;)\n\n## Configuration\n\nIt's possible to customize path and heading of your daily notes, by following the [dateformat masking syntax](https://github.com/felixge/node-dateformat#mask-options).\nThe following properties can be used:\n```json\n  \"foam.openDailyNote.directory\": \"journal\",\n  \"foam.openDailyNote.filenameFormat\": \"'daily-note'-yyyy-mm-dd\",\n  \"foam.openDailyNote.fileExtension\": \"mdx\",\n  \"foam.openDailyNote.titleFormat\": \"'Journal Entry, ' dddd, mmmm d\",\n```\n\nThe above configuration would create a file `journal/daily-note-2020-07-25.mdx`, with the heading `Journal Entry, Sunday, July 25`.\n\n"},{"fields":{"slug":"/docs/features/graph-visualization/","title":"Graph Visualization"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Graph Visualization\n---\n\nFoam comes with a graph visualization of your notes.\nTo see the graph execute the `Foam: Show Graph` command.\n\n## Graph Navigation\n\nWith the graph you can:\n- highlight a node by hovering on it, to quickly see how it's connected to the rest of your notes\n- select one or more (by keeping `shift` pressed while selecting) nodes by clicking on them, to better understand the structure of your notes\n- navigate to a note by clicking on it while pressing `ctrl` or `cmd`\n- automatically center the graph on the currently edited note, to immediately see its connections\n\n## Custom Graph Styles\n\nBy default the Foam graph will use the VsCode theme, but it's possible to customize it with the `foam.graph.style` setting.\n\nA sample configuration object is provided below, you can provide as many or as little configuration as you wish:\n\n```json\n\"foam.graph.style\": {\n    \"background\": \"#202020\",\n    \"fontSize\": 12,\n    \"highlightedForeground\": \"#f9c74f\",\n    \"node\": {\n        \"note\": \"#277da1\",\n        \"placeholder\": \"#545454\",\n        \"feature\": \"green\",\n    }\n}\n```\n\n- `note` defines the color for regular nodes\n- `placeholder` defines the color for links that don't match any existing note. This is a [[placeholder]] because no file with such name exists (see [[wiki-links]] for more info).\n- `feature` shows an example of how you can use note types to customize the graph. It defines the color for the notes of type `feature`\n  - see [[note-properties]] for details\n  - you can have as many types as you want\n\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[wiki-links]: wiki-links.md \"Wiki Links\"\n[note-properties]: note-properties.md \"Note Properties\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/features/inbox/","title":"Inbox"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Inbox\n---\n\n- Here you can write disorganised notes to be categorised later\n- Bullet points are useful, but it could be free form text as well\n- Sometimes it's better to just get things off your mind quickly, rather than stop to think where it belongs\n- But don't let this list get too long\n- Move information to more specific documents and link to them.\n  - This helps you navigate between documents quickly\n  - For example, you can `Cmd`+`Click` this: [[todo]]\n- Some notes don't end up making sense the next day\n- That's ok, you can just delete them!\n  - You can always find them in your git history, if you really need it!\n\n\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[todo]: ../how-to/todo.md \"Todo\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/features/link-reference-definitions/","title":"Link Reference Definitions"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Link Reference Definitions\n---\n\nWhen you use `[[wiki-links]]`, the [foam-vscode](https://github.com/foambubble/foam/tree/master/packages/foam-vscode) extension can generate [Markdown Link Reference Definitions](https://spec.commonmark.org/0.29/#link-reference-definitions) at the bottom of the file.\n\nThis is done to make the content of the file compatible with various Markdown tools (e.g. parsers, static site generators, VS code plugins etc), which don't support `[[wiki-links]]` directly.\n\nThis feature is disabled by default because you don't need it to navigate your workspace, it is useful for publishing and compatibility of your notes.\n\n## Example\n\nThe following example:\n  ```md\n  - [[graph-visualization]]\n  ```\n...generates the following link reference definitions to the bottom of the file:\n  ```md\n  [graph-visualization]: graph-visualization \"Graph Visualization\"\n  ```\n\n## Configuration\n\nYou can use the `foam.edit.linkReferenceDefinitions` to configure the definitions (see [[get-started-with-vscode]]):\n- `withoutExtensions` (default): this works better with certain web publishing tools (e.g. GitHub pages)\n- `withExtensions`: this works better with standard markdown-based tools (e.g GitHub web UI)\n- `off`: this disables the generation of definitions\n\nAfter changing the setting in your workspace, you can run the `Foam: Run Janitor (Experimental)` command to convert all existing definitions.\n\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[get-started-with-vscode]: ../how-to/get-started-with-vscode.md \"Getting started with VsCode - Getting-Started\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/features/note-properties/","title":"Note Properties"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Note Properties\ntype: feature\nkeywords: hello world\n---\n\n\n\nAt the top of the file you can have a section where you define your properties.\n\n> Be aware that this section needs to be at the very top of the file to be valid\n\nFor example, for this file, we have:\n```\n---\ntype: feature\nkeywords: hello world\n---\n```\n\nThose are properties.\nProperties can be used to organize your notes.\n\n## Special Properties\nSome properties have special meaning for Foam:\n- the `title` property will assign the name to the note that you will see in the graph, regardless of the filename or the first heading (also see how to [[write-notes-in-foam]])\n- the `type` property can be used to style notes differently in the graph (also see [[graph-visualization]])\n- the `tags` property can be used to add tags to a note (see [[tags-and-tag-explorer]])\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[write-notes-in-foam]: ../how-to/write-notes-in-foam.md \"Writing Notes\"\n[graph-visualization]: graph-visualization.md \"Graph Visualization\"\n[tags-and-tag-explorer]: tags-and-tag-explorer.md \"Tags and Tag Explorer\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/features/note-templates/","title":"Note Templates"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Note Templates\n---\n\nYou can create notes from templates by running the `Foam: Create New Note from Template` command and follow the instructions.\n\nTo create a template, just add regular `.md` files in `.foam/templates` (create the directory if necessary).\n\nTemplates can use all the variables available in [VsCode Snippets](https://code.visualstudio.com/docs/editor/userdefinedsnippets#_variables).\n\n"},{"fields":{"slug":"/docs/features/spell-checking/","title":"Spell Checking"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Spell Checking\n---\n\nFoam comes with a spell checker.\n\nMisspelled words are highlighted, like hellow.\nYou can place the cursor on top of the word, and press `cmd+.` for suggestions on how to fix the problem.\n\nYou can configure the extension in the settings, for example to:\n- ignore certain files\n- change the language(s)\n- and much more\n\nFor more information go to the [Spellright extension page](https://marketplace.visualstudio.com/items?itemName=ban.spellright).\n\nThere are many spell checking extensions for VsCode.\nAnother one of our favorites is [LTeX](https://marketplace.visualstudio.com/items?itemName=valentjn.vscode-ltex&ssr=false#overview), which is a bit heavier but offers some extra functionality.\n"},{"fields":{"slug":"/docs/features/tags-and-tag-explorer/","title":"Tags and Tag Explorer"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Tags and Tag Explorer\n---\n\n\n## Tags\n\nYou can add tags to your notes to categorize them, or in any way you want.\n\nThere are two ways to add tags:\n- you can add #tags just by writing them in the note\n- another way is through [[note-properties]], as you can see at the top of this file\n\n## Tag Explorer\nIn the sidebar to the left, you will see a panel called `Tag Explorer`.\n\nYou can use this panel to see the tags in your notes, and navigate them.\n\nNotice `my-tag1` and `my-tag2`, which were added via [[note-properties]].\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[note-properties]: note-properties.md \"Note Properties\"\n[note-properties]: note-properties.md \"Note Properties\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/features/wiki-links/","title":"Wiki Links"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Wiki Links\n---\n\nWiki links are the internal links that connect the files in your knowledge base.\n\nTo create a wiki link use `[[` and type the name of another file in your repo, for example [[graph-visualization]]\n\nYou can also create a [[placeholder]].\nA placeholder is a wiki link that doesn't have a target file and a link to a placeholder is styled differently so you can easily tell them apart.\nThey can still be helpful to highlight connections.\n\nOpen the graph with `Foam: Show Graph` command, and look at the placeholder node.\n\nRemember, with `CTRL/CMD+click` on a wikilink you can navigate to the note, or create it (if the link is a placeholder).\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[graph-visualization]: graph-visualization.md \"Graph Visualization\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/how-to/getting-started/","title":"Getting Started"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - Getting-Started\n---\n\n# Getting Started\n\nWelcome to your new foam workspace, let's get you started.\n\n> if you are already familiar with Foam and don't need help, just remove the `docs` folder for a clean repo.\n\nLet's go through this to set up your repo:\n\n- [ ] if you are new with VsCode, see how to [[get-started-with-vscode]] and how to [[use-keyboard-shortcuts-for-editing]]\n\n- [ ] you can navigate the links between your notes by `cmd+click` (or `ctrl+click` on Windows) on a wiki link. You can go back with `ctrl+-`. Here, go to your [[inbox]]\n\n- [ ] to see how your notes are connected, execute the `Foam: Show Graph` command. See [[graph-visualization]].\n\n- [ ] #tags can be used to further organize your content. Look at the `Tag Explorer` view on the left panel to find and navigate the tags in your knowledge base. See [[tags-and-tag-explorer]].\n\n- [ ] Foam supports [[spell-checking]].\n\n- [ ] You can also paste images in your Foam, just press `cmd+alt+v` to create the image file and link to it from your note. See [[paste-images-from-clipboard]].\n\n- [ ] You can use Foam for your daily notes, or journaling. Execute now the `Foam: Open Daily Note` command to create a new file in your `journal` folder. See [[daily-notes]].\n\n- [ ] Want to see how to manage your tasks? Go to the [[todo]] note\n\n- [ ] The section at the end of this file contains wikilink definitions, which enable navigation of your notes from GitHub's web UI, and in general to make `[[wikilinks]]` understood by any markdown parser. See [[link-reference-definitions]].\n\n- [ ] To explore all the Foam settings, press `cmd+,`, then `Extensions > Foam`\n\n- [ ] Living within VsCode, Foam can be customized in many ways! Look at the [Foam Recipes](https://foambubble.github.io/foam/recipes/recipes) for ideas!\n\n- [ ] Join the [Foam community on Discord](https://foambubble.github.io/join-discord/e), introduce yourself and leave a message on how you found Foam and how the onboarding went :) We are always keen to do better\n\n- [ ] Take the [Foam Welcome survey](http://foambubble.github.io/welcome-survey/e)! It helps us better understand your need and how we can make Foam better and better for you :)\n\n## Advanced Features\n\n- [ ] You can create [[note-templates]] for things like book reviews, people, daily notes (coming soon), and more!\n\n## About Foam\n\nFoam doesn't do all this magic on its own, it relies on some amazing extensions. Look at their documentation if you want to fully unlock the possibilities!\n\nHere they are:\n- [Markdown All In One](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one)\n- [Markdown Notes](https://marketplace.visualstudio.com/items?itemName=kortina.vscode-markdown-notes)\n- [vscode-paste-image](https://github.com/mushanshitiancai/vscode-paste-image)\n- [spellright](https://marketplace.visualstudio.com/items?itemName=ban.spellright)\n\nA special mention goes to [Markdown Links](https://marketplace.visualstudio.com/items?itemName=tchayen.markdown-links), which has now been replaced by our graph but was foundational to Foam's beginnings.\n\n\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[get-started-with-vscode]: get-started-with-vscode.md \"Getting started with VsCode - Getting-Started\"\n[use-keyboard-shortcuts-for-editing]: use-keyboard-shortcuts-for-editing.md \"Use Keyboard Shortcuts for Editing\"\n[inbox]: ../features/inbox.md \"Inbox\"\n[graph-visualization]: ../features/graph-visualization.md \"Graph Visualization\"\n[tags-and-tag-explorer]: ../features/tags-and-tag-explorer.md \"Tags and Tag Explorer\"\n[spell-checking]: ../features/spell-checking.md \"Spell Checking\"\n[paste-images-from-clipboard]: paste-images-from-clipboard.md \"Paste Images from Clipboard\"\n[daily-notes]: ../features/daily-notes.md \"Daily Notes\"\n[todo]: todo.md \"Todo\"\n[link-reference-definitions]: ../features/link-reference-definitions.md \"Link Reference Definitions\"\n[note-templates]: ../features/note-templates.md \"Note Templates\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/how-to/get-started-with-vscode/","title":"Getting started with VsCode - Getting-Started"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Getting started with VsCode\n  - Getting-Started\n---\n\nVsCode is a powerful text editor, hidden behind a simple interface.\n\n## Keyboard shortcuts\nVsCode supports various **keyboard shortcuts**, the most important for us are:\n\n| Shortcut      | Action                       |\n| ------------- | ---------------------------- |\n| `cmd+N`       | create a new file            |\n| `cmd+S`       | save the current file        |\n| `cmd+O`       | open a file                  |\n| `cmd+P`       | use quickpick to open a file |\n| `cmd+shift+P` | invoke a command (see below) |\n\nFor more information, see the [vscode keyboard cheat sheets](https://code.visualstudio.com/docs/getstarted/keybindings#_keyboard-shortcuts-reference), where you can also see how to customize your keybindings.\n\n## Commands\nCommands make VsCode extremely powerful.\n\nTo invoke a command, press `cmd+shift+P` and select the command you want to execute.\nFor example, to see the Foam graph:\n- press `cmd+shift+P`\n- start typing `show graph`\n- select the `Foam: Show Graph` command\n\nAnd watch the magic unfold.\n\nFor more information on commands, see [commands on the VsCode site](https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette).\n\n\nIf you want to learn more about VsCode, check out their [website](https://code.visualstudio.com/docs#first-steps).\n\n## Panels\n\nYou can see a few panels on the left, including:\n- `Outline`: this panel shows you the structure of the file based on the headings\n- `Tag Explorer`: This shows you the tags in your workspace, see [[tags-and-tag-explorer]] for more information on tags\n\n## Settings\n\nTo view or change the settings in VsCode, press `cmd+,`\n\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[tags-and-tag-explorer]: ../features/tags-and-tag-explorer.md \"Tags and Tag Explorer\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/how-to/primer-wiki/","title":"Foam Template for Gatsby Theme Primer Wiki"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - Getting-Started\n---\n\n# Foam Template for Gatsby Theme Primer Wiki\n\n**👋Another Foam template that use [gatsby-theme-primer-wiki](https://github.com/theowenyoung/gatsby-theme-primer-wiki), Welcome to your new Foam Knowledge Base!**\n\n## Examples\n\n- [Demo](https://demo-wiki.owenyoung.com) - ([Source](https://github.com/theowenyoung/gatsby-theme-primer-wiki/tree/main/example))\n- [Everything I Know by Owen](https://wiki.owenyoung.com/) - ([Source](https://github.com/theowenyoung/wiki))\n- [Foam Demo](https://demo-foam.owenyoung.com/) - ([Source](https://github.com/theowenyoung/foam-template-gatsby-theme-primer-wiki))\n- [Obsidian Demo](https://demo-obsidian.owenyoung.com/) - ([Source](https://github.com/theowenyoung/obsidian-template-gatsby-theme-primer-wiki))\n- [Gatsby Starter Demo](https://demo-gatsby-starter-primer-wiki.owenyoung.com/) - ([Source](https://github.com/theowenyoung/gatsby-starter-primer-wiki))\n\n## Features\n\n- Support Local search, full-text search.\n- Support Graph Visualisation with canvas.\n- Support Tags, Tags First, Generating tag pages, also connecting with graph visualisation.\n- Support [Gitbook](https://docs.gitbook.com/integrations/github/content-configuration#summary) styled `SUMMARY.md` for custom sidebar.\n- Support `[[WikiLink]]`, But you'd better use [Link Reference Definitions](https://foambubble.github.io/foam/features/link-reference-definitions) with extensions, `\"foam.edit.linkReferenceDefinitions\": \"withExtensions\"`\n- Support Light/Dark Theme\n- Custom Header Nav Items\n- Nested sidebar\n- Support Google Analytics\n- Support Sitemap/Robot\n- SEO optimization\n- Support path prefix\n\n## Principles\n\nHere are my main ideas/principles in designing this theme.\n\n1. No vendor lock-in. The less vendor features you use, the better you'll be able to migrate. `[[Wikilink]]` is the only non-markdown feature supported by default, but nonetheless, it is recommended to use the standard markdown syntax, or if you edit with [Foam](https://github.com/foambubble/foam), please use [Wikilink](https://foambubble.github.io/foam/wikilinks) with [Link Reference Definitions](https://foambubble.github.io/foam/features/link-reference-definitions). That give us the capability change our theme, or hosted place.\n2. Use meta data instead of special characters. We should use `tags` as the document's metadata, not `#tag` in the plain text.\n3. Use tags instead of categories. Minimal subfolders.\n\n## Getting started\n\n### For new wiki\n\nThis documentation assumes that you have a GitHub account and have [Visual Studio Code](https://code.visualstudio.com/) installed on your Linux/MacOS/Windows machine.\n\n1. If you haven't yet, browse over to the main [Foam documentation](https://foambubble.github.io/foam) to get an idea of what Foam is and how to use it.\n2. Press \"Use this template\" button at [foam-template-gatsby-theme-primer-wiki](https://github.com/theowenyoung/foam-template-gatsby-theme-primer-wiki/generate) (that's this repository!) to fork it to your own GitHub account. If you want to keep your thoughts to yourself, remember to set the repository private.\n3. [Clone the repository to your local machine](https://help.github.com/en/github/creating-cloning-and-archiving-repositories/cloning-a-repository) and open it in VS Code.\n\n   _Open the repository as a folder using the `File > Open...` menu item._\n\n4. When prompted to install recommended extensions, click **Install all** (or **Show Recommendations** if you want to review and install them one by one)\n5. Delete all `.md` files you don't need, Change Site settings at `.layouts/gatsby-config.js`, change your CNAME at `.layouts/static/CNAME`, change your icon at `.layouts/static/logo.png`, commit your changes, and push to github, change your page settings at Github, make sure you set the page branch to `gh-pages`, then when github actions runed, you can visit your site.\n\nAfter setting up the repository, head to [[getting-started]] to get familiar with your new knowledge base!\n\nTo learn more about how to use **Foam**, read the [Recipes](https://foambubble.github.io/foam/recipes/recipes) bubbles of the Foam documentation workspace.\n\nAnd remember that you can always join our [Foam community on Discord](https://foambubble.github.io/join-discord/g)!\n\n### For exist wiki\n\n### Exist Wiki\n\n1. Clone this repo to your local machine\n\n```bash\ngit clone https://github.com/theowenyoung/foam-template-gatsby-theme-primer-wiki.git\n```\n\n2. Copy `.layouts`, `.github` `.gitignore` to your wiki folder.\n\n## Config\n\nSee [here](https://github.com/theowenyoung/gatsby-theme-primer-wiki#usage)\n\n## Local Preview\n\n```bash\ncd .layouts\nnpm i\nnpm start\n```\n\n\n## Deploy\n\nDeploy to Github Pages, see `.github/workflows/deploy.yml`,\n\n### Path Prefix\n\nIf you want deploy your site with prefix path, \n\n1. change `gatsby-config.js` with:\n\n```javascript\nmodule.exports = {\n  pathPrefix: `/blog`,\n}\n```\n\n2. set your build script with `gatsby build --prefix-paths`,\n\n\n3. Local Preview with `gatsby serve --prefix-paths`\n\n\nAlso see the original docs: <https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/path-prefix/#add-to-gatsby-configjs>\n\n## Using Foam\n\nWe've created a few Bubbles (markdown documents) to get you started.\n\n- [[inbox]] - a place to write down quick notes to be categorized later\n- [[getting-started]] - learn how to use your Foam workspace\n- [[todo]] - a place to keep track of things to do\n\nIn the `docs` directory you can find everything you need to learn the basics of Foam.\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[getting-started]: getting-started.md \"Getting Started\"\n[inbox]: ../features/inbox.md \"Inbox\"\n[getting-started]: getting-started.md \"Getting Started\"\n[todo]: todo.md \"Todo\"\n[//end]: # \"Autogenerated link references\"\n"},{"fields":{"slug":"/docs/how-to/todo/","title":"Todo"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Todo\ntags:\n  - Getting-Started\n---\nYou can create todos in Foam.\n\n- [x] This is an example of a todo list item that's complete\n- [ ] This one is not completed yet\n- [ ] You can mark it completed by pressing `Option`+`C` (or `Alt`+`C`) when your cursor is on this line\n  - [ ] You can also select multiple lines and mark them all at once!\n\n"},{"fields":{"slug":"/docs/how-to/use-keyboard-shortcuts-for-editing/","title":"Use Keyboard Shortcuts for Editing"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Use Keyboard Shortcuts for Editing\ntags:\n  - Getting-Started\n---\n\n\nHere are some keyboard shortcuts you'll love when editing your notes.\n\nThis works best if you can see the result in the preview panel, run the `Markdown: Open Preview to the Side` command.\n\n- [ ] `alt+c` changes state to a TODO item. Try it while the cursor is on this line.\n\n---\n\n- [ ] `cmd+b` makes the selection bold. Select me and make me bold.\n\n---\n\n- [ ] `cmd+i` makes the selection italic. Select me and make me italic.\n\n---\n\n- [ ] `alt+shift+f` formats a table. Place the cursor in the table below and format the table.\n\n| column 1 | column 2|\n|-|-|\n| one element | another element|\n| second row| last cell|\n\n---\n\n- [ ] Paste link on selected text\n  1. copy the following text: https://google.com\n  2. select me and paste\n\n---\n\n- [ ] Search in your repo with `cmd+shift+f`: type \"search\"\n  - (go back to the file explorer with `cmd+shift+e`)\n\n---\n\n- [ ] Paste an image\n  1. copy an image\n  2. move your cursor to the next line, then press `cmd+alt+v` and confirm the name of the file\n  3. .\n  4. the image file has been created in `/attachments` and a reference to it has been added here\n"},{"fields":{"slug":"/docs/how-to/write-notes-in-foam/","title":"Writing Notes"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Writing Notes\ntags:\n  - Getting-Started\n---\n\nNotes are simple text files with some extra flavor, in the shape of Markdown syntax and support for extra properties (see [[note-properties]]).\n\n## Foam Syntax\n\nFoam uses standard markdown, with a few added twists:\n- the title of a note (e.g. in the [[graph-visualization]]) is given by precedence based on:\n  - the `title` property (see [[note-properties]])\n  - the first `# heading 1`  of the file\n  - the file name\n\n\n## Markdown Syntax\nWith markdown we can style our notes in a simple way, while keeping the document a simple text file (the best way to future-proof your writings!).\n\nYou can see the formatted output by running the `Markdown: Open Preview to the Side` command.\n\nHere is a high level overview of Markdown, for more information on the markdown syntax [see here](https://commonmark.org/help/).\n\nThis is a [link to google](https://www.google.com).\n\nThis is a wiki link (aka internal link) to [[note-properties]].\n\nHere is an image:\n![image](../../attachments/foam-icon.png)\n\n> this is a blockquote\n> it can span multiple lines\n\n- list item\n- list item\n- list item\n\n1. One\n2. Two\n3. Three\n\nThis text is **in bold** and this is *italic*.\n\nThe following is a horizontal rule\n\n---\n\nThis is a table:\n| Column 1 | Column 2 |\n| -------- | -------- |\n| R1C1     | R1C2     |\n| R2C1     | R2C2     |\n\nYou can `inline code` or\n```\nyou can create\ncode blocks\n```\n\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[note-properties]: ../features/note-properties.md \"Note Properties\"\n[graph-visualization]: ../features/graph-visualization.md \"Graph Visualization\"\n[note-properties]: ../features/note-properties.md \"Note Properties\"\n[note-properties]: ../features/note-properties.md \"Note Properties\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/lab/lab-main/","title":"베이즈통계 연구실"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - manual\n  - lab\n---\n\n# 베이즈통계 연구실\n\n## 1 개요 \n\n베이즈통계 연구실 관련 페이지입니다.\n\n## 2 위치, 연락처 \n\n* 교수님 연구실: 25동 314호, 02-880-xxxx\n* 대학원연구실: \n\t* 25동 312호 (24동 방향), 02-880-8138, 비밀번호 {PASSWORD}\n\t* 25동 313호 (26동 방향), 비밀번호 {PASSWORD}\n* 웹페이지: \n  * 홈페이지: https://snubayes.wordpress.com\n  * github: https://github.com/snubayes\n  * 서버: https://snubayes.duckdns.org:4443\n\n## 3 방비 \n\n* 주로 물값으로 사용\n\t* 필요할 때마다 회계담당자가 요청\n\n## 4 구성원 및 업무\n\n> 학번순으로 기입\n\n* 이재귀 (석박사통합과정) - (구) 방장\n* 이경원 (석박사통합과정) - 전산, 회계\n* 김성민 (석박사통합과정) - **방장**\n* 정진욱 (박사후연구원)\n* 오정훈 (석박사통합과정)\n* 박수원 (석사과정)\n* 장태영 (석사과정))\n\n## 5 세미나\n\n* 자세한 내용은 [[seminar/seminar|연구실 세미나]]\n\n## 6 장비\n\n### 6.1 연구실 서버\n\n* 학과 서버실에 보관중\n* 자세한 내용은 [[lab-server/server-main|연구실 서버 사용 메뉴얼]] 참고\n\n### 6.2 커피머신 \n\n* 자유롭게 쓰세요\n* 원두가 떨어져가면 마시는 사람들이 알아서 구매 부탁\n* 한 달에 한 번 분해 청소\n\n### 6.3 인터넷\n\n* 무언가 잘못되고 있다면 전산 담당에게 문의\n* 와이파이\n\t* Laplace 2.4GHz\n\t* Laplace 5GHz\n\n### 6.4 연구실  서버 \n\n### 6.5 프린터\n\n* 흑백프린터\n\t* 기종: HP LaserJet Pro M428f-M429f\n\t* 유의사항: 사용하기 위해서는 <a href=\"#63-인터넷\">와이파이</a>에 접속해야 함\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[seminar/seminar|연구실 세미나]: seminar/seminar.md \"연구실 세미나\"\n[lab-server/server-main|연구실 서버 사용 메뉴얼]: lab-server/server-main.md \"연구실 서버 사용 메뉴얼\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/statgpu/linux/","title":"리눅스 서버 사용방법"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - server\n  - manual\n  - linux\n---\n\n# 리눅스 서버 사용방법\n\n## 1 개요\n\n현재 학과 계산서버는 운영체제로 [OpenHPC](http://openhpc.community/) 리눅스를 사용하고 있다. 따라서 학과 계산서버를 사용하기 전에 리눅스 서버의 사용법을 익혀야 이를 제대로 활용할 수 있다. 비단 학과 계산서버 뿐만 아니라, 앞으로 여러분이 사용하게 될 모든 서버는 거의 확실하게 리눅스 서버이므로 서버 사용법을 익히는 것은 매우 중요하다.\n\n이 파트는 이를 위해 간단한 리눅스 서버 사용법을 다룬다. 구체적으로는 SSH를 이용한 터미널 접속부터 간단한 명령어와 텍스트 에디터 사용법, 기초적인 쉘 스크립트 명령어 및 기타 서버 사용에 매우 도움이 되는 몇몇 유틸리티나 팁들을 소개하는 것으로 내용을 진행할 것이다.\n\n이 파트에서 다루는 서버 사용법은 리눅스 서버를 사용하는데 있어 가장 기초적인 내용만을 다루고 있으므로, 자주 구글링을 하면서 매뉴얼에서 다루지 않는 사용법들도 익히는 것을 추천한다. 또한 본 매뉴얼은 사용자에게 관리자 권한이 없음을 가정하고 진행하므로, 당연히 서버 **관리**에 대해서는 다루지 않는다.\n\n 만일 리눅스 환경에 익숙하다면 [[statgpu]] 편으로 넘어가도 좋다.\n \n## 2 구성\n \n### 2.1 [[statgpu/linux/ssh]]\n\n### 2.2 [[statgpu/linux/linux]]\n\n### 2.3 [[statgpu/linux/vim]]\n\n### 2.4 [[statgpu/linux/git]]\n\n### 2.5 [[statgpu/linux/useful]]\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[statgpu]: statgpu.md \"학과 계산서버 사용법\"\n[statgpu/linux/ssh]: linux/ssh.md \"서버 접속: SSH\"\n[statgpu/linux/linux]: linux/linux.md \"기본적인 리눅스 개념 및 명령어\"\n[statgpu/linux/vim]: linux/vim.md \"텍스트 에디터: Vim\"\n[statgpu/linux/git]: linux/git.md \"버전 관리: Git\"\n[statgpu/linux/useful]: linux/useful.md \"기타 유용한 팁들\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/statgpu/statgpu-main/","title":"서울대학교 통계학과 학과서버 사용 메뉴얼"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - manual\n  - server\n---\n\n# 서울대학교 통계학과 학과서버 사용 메뉴얼\n\n## 들어가기 전에\n\n본 매뉴얼은 학과 계산서버를 이용하고 싶으나 사용에 어려움을 겪는 연구실 구성원들을 위하여 연구실 내부 공유용으로 제작된 매뉴얼이다. 관련 지식을 아무것도 모르는 구성원을 대상으로 간단한 리눅스 사용법을 알려주는 [[statgpu/linux]]편과, 어느 정도 리눅스 사용법을 아는 구성원을 대상으로 학과서버 사용법을 알려주는 [[statgpu/statgpu]]편으로 나뉜다.\n\n[[statgpu/linux]]편에 등장하는 여러 명령어/프로그램은 Unix와 비슷한 시스템을 가지고 있는 mac에서도 대부분 호환된다. 제대로 배워두면 매우 편리하다.\n  \n본 매뉴얼은 학과 계산 서버로 작업을 하기 위한 최소한의 내용만 다루고 있다. 서버로 할 수 있는 일들은 매우 다양할테지만, 여기서 그걸 모두 다룰수는 없기에 매뉴얼 관리자가 생각하기에 필요한 내용만 담겨져있다. 만일 매뉴얼에 없는 내용이지만 그것이 학과 서버를 이용하는데 필수적이라 생각이 드는 내용이 있다면, 관리자에게 연락을 취하거나 혹은 직접 문서에 기여를 하기를 부탁드린다.\n\n마지막으로, 혹시나 프로그래밍이나 컴퓨터를 다루는 것이 익숙하지 않은 사람이라면, 다음 두 어구는 항상 마음 속에 새겨두고 있자. 비단 이 매뉴얼을 읽을 때 뿐만 아니라 컴퓨터 공학(내지는 관련 분야들)을 공부할 때 반드시 필요한 자세이다.\n\n### RTFM\n\nRead the fxxxing manual. 많은 리눅스 명령어들은 이른바 [man page](https://en.wikipedia.org/wiki/Man_page)라 불리는 설명서들을 가지고 있으며, 리눅스 상에서 `man` 명령어로 쉽게 확인해볼 수 있다 (**e.g.** `man ls`, `man man`). 혹은 명령어 뒤에 `-h` 혹은 `--help` 옵션을 붙이면 대부분의 경우 간단한 사용 방법을 알려준다.\n\n### STFW\n\nSearch the fxxxing web. 많은 경우 우리가 겪을 문제들은 이미 누군가가 겪어본 문제들이고, 인터넷 어딘가에 해결방법이 있을 확률이 **매우** 높다. Google이나 [StackOverflow](https://stackoverflow.com/}{StackOverflow)에 검색 먼저 해보자.\n\n## 구성 \n\n### [[statgpu/linux|리눅스 서버 사용방법]]\n\n### [[statgpu/statgpu|학과 계산서버 사용법]]\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[statgpu/linux]: linux.md \"리눅스 서버 사용방법\"\n[statgpu/statgpu]: statgpu.md \"학과 계산서버 사용법\"\n[statgpu/linux]: linux.md \"리눅스 서버 사용방법\"\n[statgpu/linux|리눅스 서버 사용방법]: linux.md \"리눅스 서버 사용방법\"\n[statgpu/statgpu|학과 계산서버 사용법]: statgpu.md \"학과 계산서버 사용법\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/statgpu/statgpu/","title":"학과 계산서버 사용법"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - server\n  - manual\n---\n\n# 학과 계산서버 사용법\n\n## 1 개요 \n\n[[statgpu/linux]]편에서는 일반적인 리눅스 서버의 사용법에 대해 간략히 알아보았다. 이대로 바로 학과 계산서버를 사용하면 좋겠지만, 불행히도 계산서버를 사용하기 위해서는 아직 배워야할 도구들이 있다.\n\n현재 학과 계산서버는 실제 계산작업을 위한 네 개의 worker 노드와 모든 작업을 컨트롤하는 하나의 master 노드로 구성되어 있으며, 이들을 관리하는 운영체제로 OpenHPC 리눅스가 설치되어 있다. 우리가 실제로 접속할수 있는 노드는 master 노드뿐이고, 실제 worker 노드에서 계산작업을 하기 위해서는 master 노드에 설치된 도구들을 이용하여야 한다. 단순히 [[statgpu/linux]]편에서 다뤘던 내용들만 써서 프로그램을 돌린다면 worker 노드가 아니라 master 노드에서 돌아가게 되는데, master 노드의 스펙이 그리 좋지 않기 때문에 일반 데스크탑에서 돌리는 것과 큰 차이가 없을 뿐더러 서버를 사용하는 **다른 이용자에게도 피해가 간다**.\n\n본 파트에서는 worker 노드를 사용하기 위한 명령어들을 다루며, 구체적으로는 `module` 명령어와 `slurm`의 사용법을 간략히 다루고 실제 학과 서버에서 돌아가는 Python 혹은 R 코드들을 예로 들면서 마칠 계획이다.\n\n학과 계산서버를 사용하기 위해서는 당연히 계정이 필요한데, 전산조교님께 부탁하여 계정을 생성하자[^1]. 학과 계산서버의 IP 주소는 `147.46.xx.xx`이며 `xxxx`번 포트를 이용하여 접속 가능하다.\n\n[^1]: 만일 어떠한 이유로 개인 계정을 만들수 없는 경우에는 베이지안 통계학 연구실 계정을 이용할 수 있다. \n\n## 2 구성 \n\n### 2.1 [[statgpu/statgpu/slurm|Slurm 사용법]]\n\n### 2.2 [[statgpu/statgpu/module|모듈 사용법]]\n\n### 2.3 [[statgpu/statgpu/usecase|Use cases]]\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[statgpu/linux]: linux.md \"리눅스 서버 사용방법\"\n[statgpu/linux]: linux.md \"리눅스 서버 사용방법\"\n[statgpu/statgpu/slurm|Slurm 사용법]: statgpu/slurm.md \"Slurm 사용법\"\n[statgpu/statgpu/module|모듈 사용법]: statgpu/module.md \"module\"\n[statgpu/statgpu/usecase|Use cases]: statgpu/usecase.md \"Use cases\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/lab/lab-server/jupyter/","title":"JupyterHub"},"frontmatter":{"draft":false},"rawBody":"# JupyterHub\n\n연구실 서버로 Jupyter notebook을 실행할 수 있는 환경. 사용을 권장하지는 않으며 홈폴더에 conda설치 후 개별적으로 jupyter notebook + ssh 터널링을 사용할 것을 권장\n\n> https://jupyter.snubayes.duckdns.org:4443\n\n![](figs/jupyter.png)"},{"fields":{"slug":"/docs/lab/lab-server/nextcloud/","title":"NextCloud"},"frontmatter":{"draft":false},"rawBody":"# NextCloud\n\n연구실 서버에 설치되어있는 클라우드. 서버와 개인 컴퓨터를 동기화할 때 사용할 수 있다.\n\n> https://cloud.snubayes.duckdns.org:4443\n\n![](figs/nextcloud_web.png)\n\n> (중요) 사용자의 홈 폴더 내 data 디렉토리는 nextcloud의 data 디렉토리와 연동된다. \n\n1. 서버 관리자에게 계정 생성 요청\n\t1. (서버 관리자) 계정 생성\n\t2. (사용자) nextcloud 로그인 확인\n\t3. (관리자) 사용자의 홈 폴더 내 data 디렉토리를 마운트[^note]\n2. https://nextcloud.com/clients/ 에 접속해서 클라이언트 설치\n3. NextCloud 연동 \n   ![](figs/nextcloud_login.png)\n   ![](figs/nextcloud_access.png)\n4. 동기화 확인 및 사용 ![](figs/nextcloud_dir2.png)\n\n[^note]: 이후 사용자의 홈 폴더 내 data 디렉토리는 nextcloud의 data 디렉토리와 연동된다. "},{"fields":{"slug":"/docs/how-to/paste-images-from-clipboard/","title":"Paste Images from Clipboard"},"frontmatter":{"draft":false},"rawBody":"---\ntitle: Paste Images from Clipboard\ntags:\n  - Getting-Started\n---\n\n\nYou can paste an image from the clipboard with `cmd+alt+v`.\n\nImages are automatically copied to the `/attachments` folder and a reference is added in the file where you pasted them.\n\nA prompt will ask you to confirm the name of the image, to disable it set   `\"pasteImage.showFilePathConfirmInputBox\": false,` in the settings.\n\nTo change the location where the image is created, change the `pasteImage.path` property, e.g.:\n- `${currentFileDir}`: save the image next to the file\n- `${currentFileDir}/images`: create an `images` directory next to the file and save the image there\n\nFor more info check the [vscode-paste-image](https://github.com/mushanshitiancai/vscode-paste-image) extension page.\n"},{"fields":{"slug":"/docs/lab/lab-server/server-main/","title":"연구실 서버 사용 메뉴얼"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - server\n  - manual\n---\n\n# 연구실 서버 사용 메뉴얼\n\n* 관리자: 전산 담당자\n\n## 1 재원\n\n```\nOS: CentOS Linux 7 (Core) x86_64\nHost: PowerEdge R740\nKernel: 3.10.0-1160.49.1.el7.x86_64\nCPU: Intel Xeon Gold 5220R *2 (96) @ 4.000GHz\nGPU: NVIDIA RTX 3090 *1 24GB\nMemory: 257539MiB\n```\n\n## 2 접속\n\n### 2.1 도메인\n\n연구실 서버를 사용하기 위해서는 당연히 계정이 필요한데, 관리자에게 부탁하여 계정을 생성하자. 연구실 서버의 IP 주소는 `147.46.xx.xx`이며 `xxxx`번 포트를 이용하여 접속 가능하다.\n\n### 2.2 SSH\n\n> 관련 설명은 [[ssh]] 참고\n\n![](figs/ssh.png)\n\n## 3 프로그램 \n\n### 3.1 설치된 프로그램\n\n* [[rstudio]]\n* [[jupyter]]\n* [[nextcloud]]\n* [[snapdrop]]\n\n### 3.2 설치를 원하는 프로그램\n\n* 기본적으로 프로그램의 설치는 관리자에게 권한이 주어져있다. \n* 다른 프로그램의 설치를 원한다면 다음의 방법을 사용하자.\n\t1. 관리자에게 문의\n\t2. conda 등 가상환경에 설치 후 PATH 지정\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[ssh]: ../../statgpu/linux/ssh.md \"서버 접속: SSH\"\n[rstudio]: rstudio.md \"Rstudio Server\"\n[jupyter]: jupyter.md \"JupyterHub\"\n[nextcloud]: nextcloud.md \"NextCloud\"\n[snapdrop]: snapdrop.md \"Snapdrop\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/lab/lab-server/rstudio/","title":"Rstudio Server"},"frontmatter":{"draft":false},"rawBody":"# Rstudio Server \n\n연구실 서버 위에서 Rstudio를 실행할 수 있는 환경, 기본적으로 패키지는 사용자의 홈폴더에 설치된다. 자세한 사용방법은 [Rstudio 메뉴얼](https://docs.rstudio.com)을 참고\n\n> https://rstudio.snubayes.duckdns.org:4443\n\n![](figs/rstudio.png)"},{"fields":{"slug":"/docs/lab/lab-server/snapdrop/","title":"Snapdrop"},"frontmatter":{"draft":false},"rawBody":"# Snapdrop \n\n연구실 서버에 설치되어있는 P2P 파일 전송 프로그램. 사용방법 자체는 Apple의 AirDrop과 유사하다.\n\n> https://drop.snubayes.duckdns.org:4443\n\n![](figs/snapdrop.png)\n"},{"fields":{"slug":"/docs/lab/open-course/rstudio_rstan_installation_guide/","title":"R, RStudio 및 RStan 설치 가이드[^pdf-ref]"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - manual\n  - installation\n---\n\n# R, RStudio 및 RStan 설치 가이드[^pdf-ref]\n\n[^pdf-ref]: 이 장의 많은 내용들은 이재귀 학우와 김성민 학우가 기여한 'rstan 설치방법.pdf'를\n    참조하여 작성되었다.\n\n마지막 업데이트 : 2022.08.04\n\nR, RStudio 및 RStan의 정책에 따라 설치 과정이 바뀌었을 수도 있으니 \n막히는 부분이 있으면 먼저 검색을 통해 문제를 해결해 보신 후에 문의 부탁드립니다.\n\nRStudio를 설치하기 위해선, 먼저 R을 설치해야 합니다.\n\n## 1 R 설치 {#r}\n\n[R 웹사이트]에 접속하여 Download - CRAN을 선택합니다.\n\n![](fig/download_cran.png)\n\n자신의 위치와 제일 가까운 위치의 CRAN을 선택합니다.\n\n![](fig/nearest_cran.png)\n\n컴퓨터의 운영체제(OS)에 맞는 R을 설치합니다.\n\n![](fig/os_cran.png)\n\n## 2 RStudio 설치 {#rstudio}\n\n[Rstudio 웹사이트]에 접속하여 RStudio Desktop 항목 하단의 DOWNLOAD를 클릭합니다.\n\n![](fig/download_rstudio.png)\n\n컴퓨터의 운영체제(OS)에 맞는 RStudio를 설치합니다.\n\n![](fig/os_rstudio.png)\n\n## 3 RStan 설치 {#rstan}\n\nRStudio을 열고 새로운 R Script 파일에 아래의 코드를 작성하여 실행시켜 줍니다.\n\n```r\nremove.packages(\"rstan\")\nif (file.exists(\".RData\")) file.remove(\".RData\")\ninstall.packages(\"rstan\", repos = \"https://cloud.r-project.org/\", dependencies = TRUE)\n```\n\nApple M1칩 이상의 CPU가 탑재된 MacOS 컴퓨터는 아래의 코드를 실행시켜 줍니다.\n\n```r\nremove.packages(\"rstan\")\nif (file.exists(\".RData\")) file.remove(\".RData\")\ninstall.packages(\"rstan\", repos = c(\"https://mc-stan.org/r-packages/\", getOption(\"repos\")))\n```\n\n위 코드는 통계연구소를 통해 제공해드린 '계층모형실습배포용.Rmd' (혹은 '계층모형실습.R')의 앞부분에 실려있습니다.\n\n## 4 stanmodel object 컴파일 설정 {#stanmodel}\n\nRStan 설치가 완료되었으면 아래의 코드를 실행시켜 줍니다.\n\n```r\npkgbuild::has_build_tools(debug = TRUE)\n\ndotR <- file.path(Sys.getenv(\"HOME\"), \".R\")\nif (!file.exists(dotR)) dir.create(dotR)\nM <- file.path(dotR, \"Makevars\")\nif (!file.exists(M)) file.create(M)\n\nif(grepl(\"^windows\", R.version$os)){\n  cat(\"\\nCXX14FLAGS += -mtune=native -O3 -mmmx -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2\",\n      \"\\nCXX11FLAGS += -mtune=native -O3 -mmmx -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2\",\n      file = M, sep = \"\\n\", append = FALSE)\n}else if(grepl(\"^darwin\", R.version$os)){\n  arch <- ifelse(R.version$arch == \"aarch64\", \"arm64\", \"x86_64\")\n  cat(paste(\"\\nCXX14FLAGS += -O3 -mtune=native -arch\", arch, \"-ftemplate-depth-256\"),\n    file = M, sep = \"\\n\", append = FALSE)\n}else if(grepl(\"^linux\", R.version$os)){\n  cat(\"\\nCXX14FLAGS += -mtune=native -fPIC -O3 -mmmx -msse -msse2 -msse3 -mssse3 -msse4.1 -msse4.2\",\n      \"CXX14=g++\", # or clang++ but you may need a version postfix\n      file = M, sep = \"\\n\", append = FALSE)\n}else{\n  print(paste(\"Unknown OS :\", R.version$os))\n}\n```\n\n위 코드는 통계연구소를 통해 제공해드린 '계층모형실습배포용.Rmd' (혹은 '계층모형실습.R')의 앞부분에 실려있습니다.\n\n## 5 RStan 작동 검증 {#verify}\n\nRStan의 설치가 완료되면 잘 실행되는지 확인하기 위해 아래의 코드를 실행시켜 봅니다.\n\n```r\nlibrary(rstan)\nschools = \n  data.frame(y = c(28., 8., -3., 7., -1., 1., 18., 12.), \n             s =c(15., 10., 16., 11., 9., 11., 10., 18.), \n             index=c(\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\", \"H\") )\n\neightschools_indep = \"\ndata {\n  int<lower=0> J;         // number of schools \n  real y[J];              // estimated treatment effects\n  real<lower=0> sigma[J]; // standard error of effect estimates \n}\nparameters {\n  vector[J] theta;          // unscaled deviation from mu by school\n}\nmodel {\n  target += normal_lpdf(y | theta, sigma); // log-likelihood\n}\n\"\n\ndata = list(J = dim(schools)[1], y=schools$y, sigma = schools$s)\n\nfit.indep = \n  stan(model_code=eightschools_indep, data=data, \n       seed=1234567, chains=1, iter=2000, thin=10, algorithm=\"NUTS\")\n```\n\n위 코드는 통계연구소를 통해 제공해드린 '계층모형실습배포용.Rmd' (혹은 '계층모형실습.R')의 뒷부분에 실려있습니다.\n\n## 6 에러 발생 시 {#error}\n\n[stanmodel object 컴파일 설정]{#stanmodel} 단계에서 문제가 발생하면\n아래의 코드를 실행해 Makevars 파일을 열어줍니다.\n\n```r\nif(grepl(\"^linux\", R.version$os)){\n  file.edit(file.path(Sys.getenv(\"HOME\"), \".R\", \"Makevars\"))\n}else if(grepl(\"^windows\", R.version$os)){\n  file.edit(\"~/.R/Makevars.win\"))\n}else if(grepl(\"^darwin\", R.version$os)){\n  file.edit(file.path(Sys.getenv(\"HOME\"), \".R\", \"Makevars\"))\n}else{\n  print(paste(\"Unknown OS :\", R.version$os))\n}\n```\n\n만약 Makevars 파일에 '-march=native'라고 쓰인 부분이 있다면 모두 삭제한 후 Makevars 파일을 저장합니다.\n\n그 후, 위에서 했던 [stanmodel object 컴파일 설정]{#stanmodel}과\n[RStan 작동 검증]{#verify}을 다시 실행해봅니다.\n\n"},{"fields":{"slug":"/docs/lab/seminar/seminar/","title":"연구실 세미나"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - seminar\n  - lab\n---\n\n# 연구실 세미나\n\n* 베이즈통계 연구실 세미나 자료를 모아놓는 곳입니다.\n* 분기를 의미하는 폴더명은 `yyyy-Qq`로 표기 부탁드립니다. (1분기 - 봄학기, 2분기 - 여름학기, 3분기 - 가을학기 - 4분기 - 겨울학기)\n* 각 폴더 내에 발표 자료, 관련 코드들을 정리해주시고, 간략한 소개를 작성해주시면 감사하겠습니다.\n\n> 시간순으로 기입해주세요!\n\n> 발표자료 소스코드가 있는 경우 **강조** 표시 부탁드립니다\n\n## 2022\n\n* [[2022/2022_UQinDL]]\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[2022/2022_UQinDL]: 2022/2022_UQinDL.md \"A Review of Uncertainty Quantification in Deep Learning: Techniques, Applications and Challenges\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/statgpu/linux/linux/","title":"기본적인 리눅스 개념 및 명령어"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - linux\n  - programming\n  - manual\n---\n\n# 기본적인 리눅스 개념 및 명령어\n\n## 1 개요 \n\n\n물론 리눅스에도 GUI가 있긴 하지만, 대부분의 서버에는 GUI가 설치되어 있지 않고 CLI만 존재한다. 즉, 리눅스 서버를 다루고자 한다면 SSH로 쉘에 접속한 다음 텍스트로 된 명령어를 입력하고 그 결과를 텍스트로 받아보는 방식으로 서버를 사용하여야 한다. 이 장에서는 간단한 리눅스 명령어 및 개념(*e.g.* 프로세스, 쉘, 환경변수 등)들을 살펴보면서 기초적인 리눅스 사용법을 설명하고자 한다.\n\n\n## 2 `man`: 매뉴얼 보기\n\n많은 리눅스 명령어들은 이른바 man page라 불리는 설명서들을 가지고 있으며, 리눅스 상에서 `man` 명령어로 쉽게 확인해볼 수 있다. 리눅스에는 수많은 명령어들이 있고 각각이 수많은 옵션들을 가지므로, 이를 다 가르치거나 외우기가 사실상 불가능 하기 때문에 필요할 때 마다 man page를 확인하거나 구글링을 하는것을 습관으로 해야한다.\n\n```bash\n# ssh 명령에 대한 man page 표시\n$ man ssh\n# man 명령에 대한 man page 표시\n$ man man\n```\n\n## 3 파일 및 디렉터리\n\n리눅스에는 여러 파일 종류가 있는데 다음과 같다.\n\n- 일반 파일: 윈도우나 맥에서의 파일에 대응된다.\n- 디렉터리 파일: 윈도우나 맥에서의 폴더에 대응된다.\n- 장치 파일: 장치 드라이버의 인터페이스를 나타낸다. 예를 들어, 오디오\n  장치파일에 내용을 저장하면 그것이 소리로 출력된다. 리눅스에서는 거의 모든\n  것이 마치 파일처럼 관리되기 때문에 이러한 파일이 존재한다.\n- 심볼릭 링크 파일: 다른 파일에 대한 경로(참조)를 포함하는 파일로, 마치 바로가기와\n  비슷한 기능을 한다.\n\n다음은 리눅스에서 파일 관리와 관련이 깊은 명령어들이다.\n\n### 3.1 `pwd`: 현재 디렉터리의 경로 표시\n\n```bash\n$ pwd\n/home/alice\n```\n\n### 3.2 `ls`: 디렉터리의 파일 목록 표시\n\n```bash\n# /tmp 경로의 파일 목록\n$ ls /tmp\nemacs1000\n# 현재 디렉터리의 파일 목록\n$ ls\nbar  foo.txt\n# -a: 숨김파일도 보여줌; 파일명이 `.`으로 시작하는 경우 숨김파일로 간주한다.\n$ ls -a\n.  ..  .qux.txt  bar  foo.txt\n# -l: 리스트 형식으로 보여줌\n$ ls -l\ntotal 4\ndrwxr-xr-x 2 alice users 4096  3월 25 17:10 bar\n-rw-r--r-- 1 alice users    0  3월 25 17:10 foo.txt\n# -al: 리스트 형식으로 숨김파일도 보여줌\n$ ls -al\ntotal 12\ndrwxr-xr-x  3 alice users 4096  3월 25 17:12 .\ndrwx------ 13 alice users 4096  3월 25 17:13 ..\n-rw-r--r--  1 alice users    0  3월 25 17:12 .qux.txt\ndrwxr-xr-x  2 alice users 4096  3월 25 17:10 bar\n-rw-r--r--  1 alice users    0  3월 25 17:10 foo.txt\n```\n\n리스트 형식으로 파일을 보는 경우, 빈 칸으로 구분해보면 총 7개의 필드가 있는 것을 확인할 수 있는데 순서대로 (1) 타입 및 권한 (2) 링크 개수 (3) 파일 소유자 (4) 소유 그룹명 (5) 파일 크기 (6) 최종 수정 시간 (7) 파일 이름을 나타낸다.\n\n타입 및 권한은 10개 문자로 표시되는데, 1개 / 3개 / 3개 / 3개로 끊어서 읽는다. 읽는 규칙은 다음과 같다:\n\n- 첫 문자는 파일의 종류를 표시한다. `-`: 일반 파일, `d`: 디렉터리, `l`: 심볼릭\n  링크.\n- 그 외: 각각 파일 소유자, 그룹 소속원, 그 외 사용자에 대한 파일 권한을\n  나타낸다. `r`: 읽기 권한, `w`: 쓰기 권한, `x`: 실행 권한, `-`: 권한 없음.\n- 예를 들어\n  - `-rw-r--r--`: 일반 파일이며, 소유자는 읽기/쓰기 권한이 있지만 그룹\n    소속원이나 그 외 사용자는 읽기 권한만 가진다.\n  - `drwxr-x---`: 디렉토리이며, 소유자는 모든 권한을 가지지만 그룹 소속원은\n    읽기/실행 권한만 가지고, 그 외 사용자는 아무런 권한이 없다.\n\n### 3.3 `chmod`: 파일의 권한 변경\n\n```bash\n# foo.txt 파일 소유자(u)와 그룹(g)에 실행 권한(x) 추가(+).\n$ chmod ug+x foo.txt\n# 그 외 사용자(o)에 모든 읽기/쓰기 권한(rw) 제거 (-).\n$ chmod o-rw foo.txt\n# 모든 사용자(a)에 실행 권한 추가.\n$ chmod a+x foo.txt\n# 권한을 rwxr-xr-x로 변경; rwx <-> 0b111 <-> 7, r-x <-> 0b101 <-> 5.\n$ chmod 755 foo.txt\n```\n\n### 3.4 `mkdir`: 디렉터리 생성\n\n```bash\n$ mkdir /tmp/foo\n$ ls /tmp\nemacs1000  foo\n$ mkdir foo\n$ ls\nbar  foo  foo.txt\n```\n\n### 3.5 `ln`: 링크 생성\n\n```bash\n# -s: 심볼릭 링크\n$ ln -s /tmp qux\n$ ls /tmp\nemacs1000  foo\n# qux는 /tmp 경로에 대한 바로가기처럼 작동함\n$ ls qux\nemacs1000  foo\n```\n\n### 3.6 `cd`: 다른 디렉터리로 이동\n\n```bash\n# /tmp 디렉터리로 이동\n$ cd /tmp\n$ pwd\n/tmp\n$ cd foo\n$ pwd\n/tmp/foo\n# 상위 디렉터리로 이동\n$ cd ..\n$ pwd\n/tmp\n# 홈 디렉터리로 이동\n$ cd\n$ pwd\n/home/alice\n```\n\n### 3.7 `cp`: 파일이나 디렉터리를 복사\n\n```bash\n$ cp /etc/hosts .\n$ ls\nbar  foo  foo.txt  hosts  qux\n$ cp hosts hosts.txt\n$ ls\nbar  foo  foo.txt  hosts  hosts.txt  qux\n# -r: 디렉터리 복사시 하위 디렉터리를 포함하는 모든 파일들도 같이 복사\n$ cp -r bar quux\n$ ls\nbar  foo  foo.txt  hosts  hosts.txt  quux  qux\n```\n\n### 3.8 `mv`: 파일이나 디렉터리를 이동하거나 이름을 변경\n\n```bash\n$ ls\nbar  foo  foo.txt  hosts  hosts.txt  quux  qux\n$ ls quux\ntmp.txt\n$ mv hosts.txt quux/foo.txt\n$ ls\nbar  foo  foo.txt  hosts  quux  qux\n$ ls quux\ntmp.txt  hosts.txt\n$ mv quux quuux\n$ ls\nbar  foo  foo.txt  hosts  quuux  qux\n$ ls quuux\ntmp.txt hosts.txt\n```\n\n### 3.9 `rm`: 파일이나 디렉터리를 삭제\n\n```bash\n$ rm bar/tmp.txt\n# -r: 하위 디렉터리의 내용도 모두 삭제\n$ rm -r quuux\n# -f: 경고메세지 없이 바로 삭제\n$ rm -f hosts\n# 현재 디렉터리의 *모든* 파일을 바로 삭제. 조심해서 사용.\n$ rm -rf .\n# 시스템의 *모든* 파일을 바로 삭제. 따라하면 큰일남.\n$ rm -rf /*\n```\n\n## 4 입력 및 출력\n\nGUI 환경에서는 다양한 방식의 입력장치(e.g. 키보드, 마우스, 마이크, ...) 및 다양한 출력 장치(e.g. 모니터, 스피커, ...)가 있지만, CLI 환경에서는 텍스트 입력과 텍스트 출력이 유일한 입출력 장치이다. 쉘 환경에 부착된 이러한 텍스트 입출력 장치를 표준스트림이라 부른다. 표준스트림에는 총 세 가지 종류가 있는데 표준 입력(STDIN), 표준 출력(STDOUT), 표준 오류(STDERR)가 그것이다. 앞으로 입력이나 출력이 언급되는 경우는 모두 이러한 표준스트림에서의 입력이나 출력을 의미한다.\n\n우리에게 의미 있는 프로그램들은 대개 사용자들로부터 무언가를 입력 받아 처리하여 출력하는 프로그램들이다. 그러한 프로그램들을 다루기 위해서는 입출력을 적절히 원하는대로 처리할 수 있어야 할 것이다. 다음 명령어들은 표준 입출력과 관련이 있는 간단한 리눅스 명령어들이다.\n\n### 4.1 `echo`: 텍스트 또는 시스템 환경변수를 출력\n\n```bash\n$ echo student\nstudent\n$ echo I am a student\nI am a student\n$ echo HOME\nHOME\n# $: 환경변수 출력. 환경변수에 대한 설명은 쉘 스크립트 부분에서 자세히.\n$ echo $HOME\n/home/alice\n# '': strong quote; 있는 그대로 출력.\n$ echo '$HOME'\n$HOME\n```\n\n### 4.2 `cat`: 파일의 내용을 출력\n\n```bash\n$ cat /etc/environment\nPATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\"\n# 여러 텍스트를 한번에 출력할수도 있음\n$ cat /etc/environment /etc/lsb-release\nPATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\"\nDISTRIB_ID=Ubuntu\nDISTRIB_RELEASE=16.04\nDISTRIB_CODENAME=xenial\nDISTRIB_DESCRIPTION=\"Ubuntu 16.04.4 LTS\"\n# -n: 라인 번호 출력\n$ cat -n /etc/environment /etc/lsb-release\n     1  PATH=\"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games\"\n     2  DISTRIB_ID=Ubuntu\n     3  DISTRIB_RELEASE=16.04\n     4  DISTRIB_CODENAME=xenial\n     5  DISTRIB_DESCRIPTION=\"Ubuntu 16.04.4 LTS\"\n```\n\n### 4.3 `more`, `less`: 파일의 내용을 페이지 단위로 출력\n\n```bash\n$ more /etc/locale.gen\n$ less /etc/locale.gen\n```\n`less`가 `more`보다 기능이 좀 더 많다. 자세한 것은 man page 참고.\n\n### 4.4 `head`, `tail`: 파일의 처음/마지막 부분을 일부 출력\n\n```bash\n$ head /etc/locale.gen\n# -n: 출력 줄 수를 지정\n$ head -n 5 /etc/locale.gen\n$ tail /etc/locale.gen\n# -f: 파일에 내용이 추가될 때 따라서 출력. ctrl-c로 종료.\n$ tail -f /etc/locale.gen\n```\n\n### 4.5 I/O Redirections\n\n- `|`: Pipeline. 왼쪽 명령어의 출력을 바로 오른쪽 명령어의 입력으로 보낸다.\n\n    ```bash\n    $ who\n    bob      pts/0        2018-02-27 23:14 (192.168.31.41)\n    alice    pts/1        2018-03-16 01:20 (tmux(3110).%0)\n    dave     pts/2        2018-02-28 14:33 (10.0.59.26)\n    craig    pts/3        2018-03-08 03:01 (172.16.53.59)\n    $ who | sort\n    alice    pts/1        2018-03-16 01:20 (tmux(3110).%0)\n    bob      pts/0        2018-02-27 23:14 (192.168.31.41)\n    craig    pts/3        2018-03-08 03:01 (172.16.53.59)\n    dave     pts/2        2018-02-28 14:33 (10.0.59.26)\n    ```\n\n- `>`, `>>`: 명령어의 출력을 파일로 저장한다. 기존 파일이 있는 경우에 작동\n  방식이 다른데, `>`는 내용을 덮어쓰고 `>>`는 내용을 추가한다.\n\n    ```bash\n    $ echo $HOME > /tmp/foo.txt\n    $ cat /tmp/foo.txt\n    /home/alice\n    $ echo hello > /tmp/foo.txt\n    $ cat /tmp/foo.txt\n    hello\n    $ echo $HOME >> /tmp/foo.txt\n    $ cat /tmp/foo.txt\n    hello\n    /home/alice\n    ```\n\n- `<`: 명령어의 입력을 파일에서 불러온다.\n\n    ```bash\n    $ cat /etc/lsb-releases\n    DISTRIB_ID=Ubuntu\n    DISTRIB_RELEASE=16.04\n    DISTRIB_CODENAME=xenial\n    DISTRIB_DESCRIPTION=\"Ubuntu 16.04.4 LTS\"\n    $ sort < /etc/lsb-releases\n    DISTRIB_CODENAME=xenial\n    DISTRIB_DESCRIPTION=\"Ubuntu 16.04.4 LTS\"\n    DISTRIB_ID=Ubuntu\n    DISTRIB_RELEASE=16.04\n    ```\n\n## 5 파일 및 텍스트 검색\n\n### 5.1 `find`: 주어진 조건에 해당하는 파일들을 검색\n\n```bash\n# /etc/ssh와 하위 디렉토리들에서 파일명에 host를 포함하는 경우를 찾기\n$ find /etc/ssh -name '*host*'\n/etc/ssh/ssh_host_rsa_key\n/etc/ssh/ssh_host_rsa_key.pub\n/etc/ssh/ssh_host_ecdsa_key\n/etc/ssh/ssh_host_ecdsa_key.pub\n/etc/ssh/ssh_host_ed25519_key\n/etc/ssh/ssh_host_ed25519_key.pub\n# 하위 디렉토리를 제외하고 /usr 디렉토리에서 파일명이 bin으로 끝나는 경우를 찾기\n$ find /usr -maxdepth 1 -name '*bin'\n/usr/bin\n/usr/sbin\n```\n\n`find`는 수많은 종류의 조건들을 지정할 수 있으며, 또한 단순히 해당되는 파일 경로를 출력하는 것 이외에도 해당하는 파일에 대해 특정 명령을 실행하게 할 수도 있다. 강력한 명령어이므로 자세한 사항은 man page를 확인.\n\n### 5.2 `grep`: 파일 내용에서 주어진 패턴을 포함하는 라인들을 출력\n\n```bash\n$ cat /etc/lsb-releases\nDISTRIB_ID=Ubuntu\nDISTRIB_RELEASE=16.04\nDISTRIB_CODENAME=xenial\nDISTRIB_DESCRIPTION=\"Ubuntu 16.04.4 LTS\"\n# Ubuntu를 포함하는 라인들을 출력\n$ grep \"Ubuntu\" /etc/lsb-releases\nDISTRIB_ID=Ubuntu\nDISTRIB_DESCRIPTION=\"Ubuntu 16.04.4 LTS\"\n# -n: 라인 번호 포함\n$ grep -n \"Ubuntu\" /etc/lsb-releases\n1:DISTRIB_ID=Ubuntu\n4:DISTRIB_DESCRIPTION=\"Ubuntu 16.04.4 LTS\"\n# 표준 입력을 검색할 수도 있음\n$ cat /etc/lsb-releases | grep \"Ubuntu\"\nDISTRIB_ID=Ubuntu\nDISTRIB_DESCRIPTION=\"Ubuntu 16.04.4 LTS\"\n# Ubuntu를 포함하지 않는 라인들을 출력\n$ grep -v \"Ubuntu\" /etc/lsb-releases\nDISTRIB_RELEASE=16.04\nDISTRIB_CODENAME=xenial\n# -i: 대소문자 구분 없이 검색\n$ grep -i \"uBuNTu\" /etc/lsb-releases\nDISTRIB_ID=Ubuntu\nDISTRIB_DESCRIPTION=\"Ubuntu 16.04.4 LTS\"\n```\n\n`grep` 역시 강력한 툴이므로 man page 및 구글링을 통해 자세한 옵션들을 확인.\n\n### 5.3 정규표현식 (Regex, Regexp)\n\n정규표현식은 특정 규칙을 포함하는 문자열을 찾기위한 형식 언어의 하나이다. 프로그래밍 작업을 할 때 필요하다 싶은 거의 모든 문자열 패턴들을 정규표현식으로 작성할 수 있는데, 예를 들어:\n\n- `[a-zA-Z]+`: 임의의 영어 단어를 나타내는 정규표현식.\n- `[0-9]+`: 자연수를 나타내는 정규표현식.\n- `(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?`: 웹페이지의\n  URL을 나타내는 정규표현식.\n- `([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})`: 이메일 주소를 나타내는\n  정규표현식.\n- `(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)`:\n  IP 주소를 나타내는 정규표현식\n\n실제로 앞서 다룬 `find`나 `grep` 둘 다 정규표현식을 지원하며, 여러 리눅스 명령어나 도구들이 정규표현식을 지원한다. 다만 정확한 문법은 명령어나 도구마다 약간씩 다르므로 주의를 해야한다. 자세한 사용법은 구글링으로 확인.\n\n## 6 프로세스\n\n프로세스는 메모리에 로드되어 실행 중인 프로그램의 인스턴스를 의미한다. 운영체제는 context switching 및 virtual address space을 이용해 프로세스의 실행을 제어하며, 이를 위해 모든 프로세스는 PCB라고 하는 공간에 제어에 필요한 여러 정보들을 저장한다. 일반적으로 PCB에는 프로세스의 ID(PID라 한다), 현재 상태, 스케쥴링 정보 같은 각종 정보들을 저장하고 있다.\n\nPC를 사용할 때 보통 여러 개의 창을 동시에 띄워놓고 작업을 하다 필요 없는 프로그램은 닫곤 하는데, 리눅스에서도 마찬가지로 여러 프로세스을 동시에 돌리거나 필요 없는 프로세스를 종료 할 수 있는 명령어들을 제공한다.\n\n### 6.1 Job Control\n\n대부분의 경우 쉘에서 명령어를 입력하는 것은 그 명령어에 해당되는 프로그램을 새 프로세스로 로딩하여 실행하는 것과 같다. 이 때, foreground job과 background job 두 가지로 구분할 수 있다.\n\nForeground job으로 실행하면 쉘은 실행된 프로세스가 종료될 때 까지 wait 상태로 들어간다. 실행된 프로세스가 종료되면서 쉘에 exit 신호를 보내면 그 때 쉘은 wait 상태가 풀린다. 따라서, 프로세스가 실행되는 동안은 쉘이 wait 상태로 들어가며 그 동안은 명령어를 입력받지 못하는 상태가 된다.\n\n```bash\n# Foreground job\n$ sleep 10\n# 10초뒤에 명령 프롬프트가 나타남; 프로세스가 종료되기 전까지는 명령어를 입력할 수 없다\n$\n```\n\n만일 명령어 뒤에 `&`를 붙인다면 background job으로 프로세스를 실행하는데, 이 경우 쉘은 자식 프로세스의 종료를 기다리지 않는다. 즉, 프로세스가 실행되는 동안에도 쉘은 다른 명령어를 입력 받을수 있다.\n\n```bash\n# Background job\n$ sleep 10 &\n[1] 180808\n# 바로 명령 프롬프트가 나타남; 프로세스의 종료 여부와 상관없이 명령어를 입력할 수 있다\n$ \n# background에서 돌아가던 프로세스가 종료되는 순간에 쉘에 아래와 같은 메세지를 출력한다.\n[1]  + 180808 done       sleep 10\n```\n\n당연히 foreground에서 background로 혹은 background에서 foreground로 쉽게 전환할 수 있다. 뿐만 아니라 간단한 명령어를 이용해 job들을 일시정지하거나 종료시킬 수도 있다. 이러한 작업 전환은 기본적으로 시그널을 기반으로 하는데, 시그널에 대한 자세한 설명은 잠시 뒤에 다루도록 한다.\n\n```bash\n# foreground로 실행\n$ sleep 1000\n# ctrl-z (Control key + Z) 입력: 실행중인 foreground job을 일시정지\n^Z\n[1]  + 182183 suspended  sleep 1000\n# 쉘에서 관리중인 job들을 표시\n$ jobs\n[1]  + suspended  sleep 1000\n# 일시정지된 1번 job을 background job으로 실행\n$ bg %1\n[1]  + 182183 continued  sleep 1000\n# 실행중인 1번 background job을 일시정지\n$ kill -STOP %1\n[1]  + 182183 suspended (signal)  sleep 1000\n# 일시정지된 1번 job을 foreground job으로 실행\n$ fg %1\n# ctrl-c 입력: foreground job을 종료\n^C\n$ sleep 1000 &\n[1] 182201\n# 실행중인 1번 background job을 종료\n$ kill %1\n[1]  + 182201 terminated  sleep 1000\n```\n\n![Job control](../img/jobs.png)\n\n### 6.2 프로세스 출력\n\nJob control의 경우는 현재 쉘에서 실행되었던 프로그램만 관리할 수 밖에 없다는 단점이 있다. 다른 프로세스를 관리하고자 한다면 먼저 어떤 프로세스가 있는지 등을 확인해야 할텐데 다음 명령어들은 이를 위한 기능들을 제공한다.\n\n- `ps`: 현재 실행중인 프로세스 및 상태를 출력한다. 보통은 `ps -aux`나 `ps -ef`와 같은 옵션을 주어 실행한다.\n\n- `pgrep`: 프로세스의 이름을 검색하여 해당하는 프로세스의 PID를 출력한다.\n\n### 6.3 시그널\n\n시그널은 프로세스간 통신에 쓰이는 일종의 신호로서, exceptional control flow를 제어하기 위한 운영 체제의 기능이다. 리눅스에서 쓰이는 시그널 중 대표적인 것들은 다음과 같다:\n\n- SIGHUP: Terminal line hangup\n- SIGINT: Interrupt from keyboard\n- SIGQUIT: Quit from keyboard\n- SIGKILL: Kill program\n- SIGSEGV: Segmentation fault (illegal memory ref)\n- SIGTERM: Software termination signal\n- SIGCHLD: A child process has stopped or terminated\n- SIGCONT: Continue process if stopped\n- SIGSTOP: Stop signal not from terminal\n- SIGTSTP: Stop signal from terminal\n\n앞서 다뤘던 예제들을 살펴보면:\n\n- ctrl-z: Foreground job에 SIGTSTP를 보낸다.\n- `kill -STOP %n`: n번 background job에 SIGSTOP을 보낸다.\n- ctrl-c: Foreground job에 SIGINT를 보낸다.\n- `kill %n`: n번 background job에 SIGTERM을 보낸다.\n\n프로세스에 시그널을 보내는 위한 쉘 명령어들은 다음이 있다:\n\n- `kill`: 해당 job ID(`%`를 붙인 경우)를 가지는 job 혹은 PID(`%`를 안붙인 경우)를 가지는 프로세스에 해당하는 시그널을 전달한다. 옵션없이 실행되는 경우는 SIGTERM을 보낸다.\n- `pkill`: 해당 이름을 가지는 프로세스에 시그널을 전달한다.\n- `killall`: 특정 이름을 가지는 모든 프로세스에 시그널을 전달한다.\n\n## 7 쉘 스크립트\n\n스크립트 혹은 스크립트 언어는 프로그래밍 언어의 한 종류로, 기존에 이미 존재하는 프로그램을 제어하기 위한 용도로 쓰이는 언어이다. 리눅스 쉘은 처음 단순히 사용자의 명령을 받아 실행시키는 기능만 있었지만, 이후에 여러 스크립트 기능들이 부가적인 기능들로서 추가되었다.\n\n\n쉘 스크립트는 기본적으로 텍스트 파일로 작성된다. `sayhello.sh` 파일을 만들어 다음과 같이 작성하자[^linux-1]:\n\n\n\n[^linux-1]: 만일 리눅스에서 텍스트 에디터를 쓰는 법을 모른다면 [[vim]]을 먼저 보고 다시 여기로 와도 좋다.\n\t\n\n```{.bash .numberLines}\n#!/bin/bash\ndate\necho hello world!\n```\n\n맨 첫 줄은 `#!`로 시작하고, 그 뒤에 스크립트를 실행할 프로그램의 경로를 적어준다. 이 경우는 `bash` 쉘을 이용한 스크립트를 짤 것이기 때문에 `/bin/bash`를 뒤에 붙인다. 그 다음 줄부터는 실제로 실행할 명령어들을 차례로 적어주면 된다. 이제 쉘에서 실행 권한을 주고 실제로 실행을 해보면 파일에 작성했던 대로 명령어들이 실행되는 것을 확인할 수 있다.\n\n```bash\n$ chmod +x sayhello.sh\n$ ./sayhello.sh\nThu Mar 29 17:02:55 KST 2018\nhello world!\n```\n\n`sayhello.sh`는 단순한 명령어들만 실행시키지만, 스크립트 기능들을 이용한다면 단순히 명령어를 실행하는 것보다 더 복잡한 작업들을 수행할 수 있게 된다. 요컨대, for 문을 이용하여 여러 개의 파일에 대해 특정 작업을 하거나, if 문을 활용하여 프로그램의 오류가 발생했을 때 특정한 작업을 하도록 하는 등의 작업들이 가능하다. 물론, 이를 파일에 저장하지 않고 바로 쉘에 한줄 한줄씩 입력하여도 (불편하긴 하지만) 실행이 가능하다.\n\n이러한 스크립팅을 지원하기 위해 쉘은 사용자에게 받은 명령을 먼저 해석한 후 실행하며, 따라서 정확한 쉘 스크립트 기능을 모른다면 우리가 원하는 결과와 다른 결과를 얻을 수도 있다. 다음 예를 보자.\n\n```bash\n# 쉘에서 입력받은 인자들을 그대로 출력하는 명령어\n$ alias myparse=\"python -c 'import sys; print(sys.argv[1:])'\"\n$ myparse hello world\n['hello' 'world']\n$ myparse {1..3} $(( 1 + 3 )) \"$(echo $HOME)\"\n['1', '2', '3', '4', '/home/alice']\n```\n\n분명히 쉘에서 명령어를 작성할 때는 `{1..3}`, `$(( 1 + 3 ))`, `\"$(echo $HOME)\"`와 같은 인수들을 사용했는데, 실제 명령어의 전달된 인수들은 쉘이 이를 해석하여 다르게 나타난 것을 확인할 수 있다. 만일 `{1..3}`, `$(( 1 + $num ))`, `\"$(echo $HOME)\"`로 된 인수를 그대로 사용하려는 것이 원래 목적이였다면 특수한 처리를 해주어야 한다.\n\n매뉴얼에는 기초적인 스크립트 작성시 필요한, 그리고 주의해야 할 내용들만 간략히 서술하였다. 스크립트 작성에 관한 자세한 내용은 [mug896]님의 [Bash 쉘 스크립트 가이드]를 참조하라.\n\n### 7.1 주석 (Comment)\n\nBash에서 `#` 뒤에 붙는 문자열들은 주석으로 처리된다. 단, 모든 `#`가 주석으로 처리되지는 않는데, 다음 두 조건 중 하나에 해당되어야 한다:\n\n- `#`가 맨 앞에 있음\n- `#` 바로 앞에 공백문자가 있음\n\n만일 `#`를 주석처리하고 싶지 않다면 escape 혹은 quote를 씌운다. 자세한 설명은 후술.\n\n### 7.2 공백 문자\n\n모든 쉘 명령어들은 공백으로 분리되어 해석된다. 요컨대, 공백으로 분리되지 않은 문자열들은 하나의 명령어나 혹은 하나의 인수로 해석된다. 사소해 보이지만 자주 오류의 원인이 되는데, 다음 예제를 보면서 확인하도록 하자.\n\n```bash\n# 정상 실행\n$ { echo 1; echo 2 ;}\n1\n2\n# 에러: `{` 키워드와 `echo` 명령을 붙였기 때문에 `{echo`를 명령어로 해석함\n$ {echo 1; echo 2 ;}\nbash: syntax error near unexpected token '}'\n\n# 대입 명령. 등호 양 옆에 *반드시* 공백이 없어야함\n$ foo=42\n$ echo $foo\n42\n# 에러: `foo`를 명령어로, `=42`를 인수로 해석하므로\n$ foo =42\nfoo: command not found\n# 에러: `foo=`를 공백대입명령으로, `42`를 명령어로 해석하므로\n$ foo= 42\n42: command not found\n```\n\n### 7.3 Quotes and escaping\n\n앞서 보았듯 쉘에서 공백 문자나 `#` 같이 특수한 기능을 가지는 문자들은 단순한 문자로 처리되지 않는다. 따라서 이러한 문자들을 단순한 문자로 처리하기 위해서는 quote를 씌우거나 escaping을 해야한다.\n```bash\n# `#`가 주석으로 처리되어 아무것도 출력하지 않음\n$ echo #\n# escaping: backslash를 앞에 붙인다.\n$ echo \\#\n#\n# weak quoting: 큰 따옴표로 감싼다.\n$ echo \"#\"\n#\n# strong quoting: 작은 따옴표로 감싼다.\n$ echo '#'\n#\n```\n\n`\\`, `'`, `\"` 또한 특수한 기능을 가진 문자기에, 단순한 문자로 처리하기 위해서는 이들 또한 quote를 씌우거나 escaping을 해야한다.\n\n```bash\n$ echo \\\"\n\"\n$ echo '\"'\n\"\n```\n\n### 7.4 변수\n\n```bash\n# 변수 대입: 괄호 양 옆에 공백이 *반드시* 없어야한다.\n$ foo=\"Hello world\"\n# $: 변수확장; 변수를 참조할 때는 $를 앞에 붙인다\n$ echo $foo\nHello world\n# $를 생략한 경우\n$ echo foo\nfoo\n# $(): 명령치환; 괄호 안의 명령을 실행한 뒤 출력 결과를 참조한다\n$ bar=$(whoami)\n$ echo $bar\nalice\n# Weak quotation의 경우, quote 안에 있는 변수확장이나 명령치환을 실행한다.\n$ qux=\"$foo, $bar.\"\n$ echo $qux\nHello world, alice.\n# Strong quotation의 경우는 실행하지 않는다.\n$ qux='$foo, $bar.'\n$ echo $qux\n$foo, $bar.\n```\n\n### 7.5 환경 변수\n현재 쉘 환경과 직접적으로 연관이 되는 변수들을 환경 변수라 하며, 쉘이 생성하거나 참조하는 변수들이다. 이 변수들을 바꾸어 쉘의 작동에 영향을 끼칠 수 있다. 대표적인 환경 변수들은 다음이 있다:\n\n```bash\n# USER: 사용자 계정 이름\n$ echo $USER\nalice\n# HOME: 홈 디렉토리 경로\n$ echo $HOME\n/home/alice\n# PWD: 현재 디렉토리 경로\n$ echo $PWD\n/home/alice\n# PATH: 실행할 프로그램의 위치들; PATH 경로에 있는 프로그램은 정확한 경로를 입력할 필요없이 프로그램 이름만으로 실행할 수 있다.\n$ echo $PATH\n/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\n```\n\n## 8 기타\n\n- `wget`: 웹에 있는 파일을 서버로 다운로드한다.\n- `htop`: 현재 서버의 CPU, 메모리 사용량 등에 대한 정보를 보여준다.\n- `time`: 명령어의 실행 시간을 측정한다.\n- `exit`, `logout`: 쉘을 종료한다.\n- `ctrl-d`: EOF(End-of-file) 캐릭터. 쉘에서 입력할 경우 쉘을 종료한다.\n\n[//begin]: # \"Autogenerated link references for markdown compatibility\"\n[vim]: vim.md \"텍스트 에디터: Vim\"\n[//end]: # \"Autogenerated link references\""},{"fields":{"slug":"/docs/statgpu/linux/git/","title":"버전 관리: Git[^git-ref]"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - programming\n  - git\n  - manual\n---\n\n# 버전 관리: Git[^git-ref]\n\n## 1 개요\n\n[^git-ref]: 이 장의 많은 내용들은 Scott Chacon and Ben Straub의 [Pro Git]을\n    참조하여 작성되었다.\n\n버전 관리 시스템(VCS; Version Control System)은 파일의 여러 버전을 손쉽게\n관리하기 위한 프로그램이다. 많은 경우, 프로젝트를 진행하면서 새로운 버전을 만들\n때마다 새 폴더나 파일을 복사한 뒤 이를 수정하는 방식을 사용하는데, 파일을\n편집할 때마다 매번 복사하는 일은 번거롭기도 하고 또 파일의 어떤 부분이 변경된\n것인지 파악하기도 힘들다. 더군다나 여러 명이 협업하는 경우에는 실수로 다른\n사람이 수정한 부분을 덮어씌우거나 하는 등 실수할 가능성도 크다. VCS를 이용하여\n버전을 기록한다면 각 파일을 이전 상태로 되돌릴 수 있고, 프로젝트를 통째로 이전\n상태로 되돌릴 수 있고, 시간에 따라 수정 내용을 비교해 볼 수 있고, 누가 문제를\n일으켰는지도 추적할 수 있고, 누가 언제 만들어낸 이슈인지도 알 수 있다. VCS를\n사용하면 파일을 잃어버리거나 잘못 고쳤을 때도 쉽게 복구할 수 있다. 이런 모든\n장점을 큰 노력 없이 이용할 수 있다.\n\n[Git]은 VCS 중 하나로, 현재 소프트웨어 개발에서 사실상 표준으로 사용되는\nVCS이다. 소프르웨어 개발 뿐만 아니라 TeX으로 된 페이퍼를 작성하는 경우 같이\n텍스트 파일로 된 프로젝트의 경우 쉽게 Git을 적용할 수 있다[^git-1]. Git은 CLI\n도구로서 터미널에서 사용하지만, Git을 사용하기 위한 여러 GUI도 개발되어\n있다. 본 매뉴얼에서는 CLI 환경에서 사용법만 다루기로 한다. 매뉴얼에는 기초적인\nGit 사용법들만 간략히 서술하였으며, 자세한 내용은 [Pro Git] 같은 다양한\n레퍼런스들을 참조하라.\n\n[^git-1]: 본 매뉴얼도 Git으로 관리되고 있다.\n\n본격적으로 Git을 사용하기 전에, 먼저 Git을 설치한 다음에 사용자 이름과 이메일을\n다음과 같은 명령어를 이용하여 설정하여야 한다:\n\n```bash\n$ git config --global user.name \"Alice\"\n$ git config --global user.email \"alice@mail.com\"\n```\n\n## 2 저장소\n\n저장소(Repository)는 말 그대로 Git이 파일이나 폴더를 저장하는 곳으로, 보통은\n작업 디렉토리(Working directory) 안에 `.git` 폴더 형태로 존재한다. 대부분의\n경우 사용자는 `.git` 폴더를 신경쓸 필요 없이 작업 디렉토리에서 작업을 하다가\n중간중간 Git 명령어들을 이용해 Git 프로그램이 자동적으로 `.git` 폴더를 관리하는\n형식으로 작업이 진행되게 된다.\n\n저장소는 다음의 두 방법으로 만들 수 있다. 먼저 작업이 저장되어 있는 다른\n저장소를 가져오는 방법이 있는데, 원격 서버의 저장소를 복제하려면 `git clone`을\n실행한다:\n```bash\n$ cd /tmp\n# GitHub에 저장된 저장소 simplegit-progit을 로컬의 cloned 폴더로 복제한다.\n$ git clone https://github.com/schacon/simplegit-progit cloned\nCloning into 'cloned'...\nremote: Counting objects: 13, done.\nremote: Total 13 (delta 0), reused 0 (delta 0), pack-reused 13\nUnpacking objects: 100% (13/13), done.\n$ ls cloned\nlib  Rakefile  README\n```\n\n새로운 저장소를 만들기 위해서는 저장소로 만들고자 하는 폴더 안에서 `git init`을\n실행하면 새 저장소가 생성된다:\n```bash\n$ cd /tmp\n$ mkdir repo\n$ cd repo\n$ echo \"# Git Tutorial\" > README.md\n$ ls\nREADME.md\n# git status: 현재 Git 저장소의 상태를 표시하는 명령어. 아직 저장소를 만들지 않아 에러가 발생한다\n$ git status\nfatal: not a git repository (or any parent up to mount point /)\nStopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set).\n$ git init\nInitialized empty Git repository in /tmp/repo/.git/\n$ git status\nOn branch master\n\nNo commits yet\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n    README.md\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n\n위 예의 메세지를 보면 알겠지만 기존에 있던 파일들이 Untracked 상태임을 알 수\n있다. 요컨대, `git init` 명령만으로는 Git이 아직 프로젝트의 어떤 파일도\n관리하지 않으며, Git이 파일을 track하게 하려면 추가로 명령을 실행하여야\n한다. 그 전에, Git이 어떤 식으로 파일을 관리하는지 간단히 알아볼 필요가 있다.\n\n## 3 추가와 커밋\n\nGit으로 하는 일은 기본적으로 아래와 같다:\n\n1. 평소처럼 작업 디렉토리에서 파일을 수정한다.\n2. Git이 추적하고자 하는 변경 사항들을 `git add` 명령을 이용해 Staging\n   Area에 기록한다.\n3. `git commit` 명령을 이용해 Stage된 변경 사항들을 (별도의 메세지와 함께)\n   저장소에 영구적으로 기록한다.\n\n![작업 디렉토리, Staging Area, 저장소](../img/git-stages.png)\n\n실제로 Git을 쓰면서 우리가 편집할 모든 파일들은 전부 작업 디렉토리에 속하므로,\n이에 대해 자세히 알아보자. 작업 디렉토리의 모든 파일은 크게 Tracked와\nUntracked로 나뉜다. Untracked 파일은\n작업 디렉토리에 있는 파일 중 저장소에도 Staging Area에도 포함되지 않은\n파일이다. Untracked 파일들은 Git이 전혀 추적하지 않기 때문에 (추적하라고 따로\n명령어를 주기 전까지는) 무슨 짓을 하더라도 계속 untracked 상태로 남는다.\n\n![파일의 라이프사이클](../img/git-lifecycle.png)\n\nTracked 파일은 예전에 한번 커밋된 적이 있어 저장소에 있거나 혹은 현재 Staging\nArea에 있는 파일이다. Tracked 파일은 다시 또 Unmodified, Modified, Staged 상태\n중 하나로 구분된다. Unmodified 파일은 현재 작업 디렉토리에 있는 파일이 저장소에\n있는 파일과 같은 경우를 뜻하며, 만일 Unmodified 파일을 수정하면 Git은 그 파일을\nModified 상태로 인식한다. 다만, modified 상태의 파일은 commit 명령을 하더라도\n저장소에 기록되지 않는데, 저장소에 기록되기 위해서는 modified 상태가 아닌\nstaged 상태가 되어야 한다. 이를 이용해서 현재 작업 디렉토리에서 이력으로 남기고\n싶은 부분만 커밋을 하는 식으로 버전 관리를 할 수 있다.\n\n실제 예제를 확인해보도록 하자. 앞서 clone한 디렉토리로 가서 `git status`\n명령어를 실행해보자:\n```bash\n$ cd /tmp/cloned\n$ git status\nOn branch master\nYour branch is up to date with 'origin/master'.\n\nnothing to commit, working tree clean\n```\n위의 내용은 작업 디렉토리의 모든 파일이 unmodified 상태임을 의미한다. Untracked\n파일은 아직 없어서 목록에 나타나지 않는다. 그리고 첫번째 줄에서 현재 작업 중인\n브랜치의 이름(여기서는 master)을 알려주며 두번째 줄은 서버의 같은 브랜치로부터\n진행된 작업이 없는 것을 나타낸다.\n\n프로젝트에 `CONTRIBUTING.md` 파일을 만들어보면, 새로운 파일이기 때문에 Git이\nUntracked files로 처리되는 것을 확인할 수 있다:\n```bash\n$ touch CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up to date with 'origin/master'.\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n    CONTRIBUTING.md\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\nGit은 Untracked 파일을 아직 커밋에 넣어지지 않은 파일이라고 여기며, 파일이\nTracked 상태가 되기 전까지는 Git은 절대 그 파일을 커밋하지 않는다. 그래서\n일하면서 생성하는 바이너리 파일 같은 것을 커밋하는 실수는 하지 않게\n된다. `git add` 명령어로 `CONTRIBUTING.md` 파일을 추가해서 직접 Tracked 상태로\n만들어보자:\n```bash\n$ git add CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is up to date with 'origin/master'.\n\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   CONTRIBUTING.md\n```\n상태를 보면 알겠지만 단순히 Tracked 파일로 추가한 것 뿐만이 아니라 `Changes to\nbe committed` 상태, 즉 Staged를 의미한다.\n\n이미 Tracked 상태인 파일을 수정하는 법을 알아보자. `README`라는 파일을 수정하고 나서 git status\n명령을 다시 실행하면 결과는 아래와 같다.\n```bash\n$ echo \" Jr.\" >> README\n$ git status\nOn branch master\nYour branch is up to date with 'origin/master'.\n\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   CONTRIBUTING.md\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   README\n```\n이 `README` 파일은 `Changes not staged for commit`에 있다. 이것은 수정한 파일이\nTracked 상태이지만 아직 Staged 상태는 아니라는 것이다. Staged 상태로 만들려면\n`git add` 명령을 실행해야 한다. `git add` 명령은 파일을 새로 추적할 때도\n사용하고 수정한 파일을 Staged 상태로 만들 때도 사용한다. Merge 할 때 충돌난\n상태의 파일을 Resolve 상태로 만들때도 사용한다. `add`의 의미는 프로젝트에\n파일을 추가한다기 보다는 다음 커밋에 추가한다고 받아들이는게 좋다.\n```bash\n$ git add README\n$ git status\nOn branch master\nYour branch is up to date with 'origin/master'.\n\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   CONTRIBUTING.md\n    modified:   README\n```\n두 파일 모두 Staged 상태이므로 다음 커밋에 포함된다. 하지만 아직 더 수정해야\n한다는 것을 알게 되어 바로 커밋하지 못하는 상황이 되었다고 생각해보자. 이\n상황에서 `README` 파일을 열고 수정한다. 이제 커밋할 준비가 다 됐다고 생각할\n테지만, Git은 그렇지 않다.\n```bash\n$ echo \"Lorem ipsum\" >> README\n$ git status\nOn branch master\nYour branch is up to date with 'origin/master'.\n\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n    new file:   CONTRIBUTING.md\n    modified:   README\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   README\n```\n`README`가 Staged 상태이면서 *동시에* Unstaged 상태로 나온다. 어떻게 이런 일이\n가능할까? `git add` 명령을 실행하면 Git은 파일을 바로 Staged 상태로\n만든다. 지금 이 시점에서 커밋을 하면 `git commit` 명령을\n실행하는 시점의 버전이 커밋되는 것이 아니라 마지막으로 `git add` 명령을\n실행했을 때의 버전이 커밋된다. 그러니까 `git add` 명령을 실행한 후에 또 파일을\n수정해서 커밋하고 싶으면 `git add` 명령을 다시 실행해서 최신 버전을 Staged\n상태로 만들어야 한다.\n\n## 4 변경 사항 비교\n\n단순히 파일이 변경됐다는 사실이 아니라 어떤 내용이 변경됐는지 살펴보려면 `git\nstatus` 명령이 아니라 `git diff` 명령을 사용해야 한다. 보통 우리는 '수정했지만,\n아직 Staged 파일이 아닌 것?'과 '어떤 파일이 Staged 상태인지?'가 궁금하기 때문에\n`git status` 명령으로도 충분하다. 더 자세하게 볼 때는 `git diff` 명령을\n사용하는데 Patch처럼 어떤 라인을 추가했고 삭제했는지가 궁금할 때 사용한다.\n\n그냥 `git diff`를 실행하면 수정했지만 아직 staged 상태가 아닌 파일을 비교해 볼\n수 있다. 즉, 작업 디렉토리의 내용과 Staging area의 내용을 비교해준다. 이 때,\n`git diff` 명령은 마지막으로 커밋한 후에 수정한 것들 전부를 보여주지\n않는다. `git diff` 는 Unstaged 상태인 것들만 보여준다. 이 부분이 조금 헷갈릴 수\n있다. 수정한 파일을 모두 Staging Area에 넣었다면 `git diff` 명령은 아무것도\n출력하지 않는다.\n```bash\n$ git diff\ndiff --git a/README b/README\nindex 249dbdc..573cec9 100644\n--- a/README\n+++ b/README\n@@ -4,3 +4,4 @@ SimpleGit Ruby Library\n \n This library calls git commands and returns the output.\n \nAuthor : Scott Chacon Jr.\n+Lorem ipsum\n```\n저장소에 커밋한 것과 Staging Area에 있는 것을 비교하려면 `git diff --staged`를\n이용한다:\n```bash\n$ git diff --staged\ndiff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\nnew file mode 100644\nindex 0000000..e69de29\ndiff --git a/README b/README\nindex a906cb2..fbc2d04 100644\n--- a/README\n+++ b/README\n@@ -3,4 +3,4 @@ SimpleGit Ruby Library\n \n This library calls git commands and returns the output.\n \n-Author : Scott Chacon\n+Author : Scott Chacon Jr.\n```\n\n## 5 변경사항 커밋하기\n\n수정한 것을 커밋하기 위해 Staging Area에 파일을 정리했다. Unstaged 상태의\n파일은 커밋되지 않는다는 것을 기억해야 한다. Git은 생성하거나 수정하고 나서\n`git add` 명령으로 추가하지 않은 파일은 커밋하지 않는다. 그 파일은 여전히\nModified 상태로 남아 있다. 커밋하기 전에 `git status` 명령으로 모든 것이 Staged\n상태인지 확인할 수 있다. 그 후에 `git commit` 을 실행하여 커밋하는데, `-m`\n옵션을 사용하여 커밋 메세지를 첨부하여야 한다.\n```bash\n$ git commit -m 'statgpu Tutorial'\n[master 5175e4c] statgpu tutorial\n 2 files changed, 1 insertion(+), 1 deletion(-)\n create mode 100644 CONTRIBUTING.md\n$ git status\nOn branch master\nYour branch is ahead of 'origin/master' by 1 commit.\n  (use \"git push\" to publish your local commits)\n\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n    modified:   README\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n```\n메세지로부터 쉽게 알 수 있듯, `README` 파일과 `CONTRIBUTING.md`의 수정 내역이\n성공적으로 커밋되었으며, 앞선 예제에서 Stage하지 않았던 `README`의 수정 부분은\n커밋되지 않고 modified 상태로 계속 남아있음을 확인할 수 있다. Git은 Staging\nArea에 속한 스냅샷을 커밋한다는 것을 기억해야 한다. 수정은 했지만, 아직 Staging\nArea에 넣지 않은 것은 다음에 커밋할 수 있다. 커밋할 때마다 프로젝트의 스냅샷을\n기록하기 때문에 나중에 스냅샷끼리 비교하거나 예전 스냅샷으로 되돌릴 수 있다.\n\n## 6 파일 삭제 및 이름 변경\n\n`git rm` 및 `git mv` 명령어를 사용한다. 그냥 `rm`나 `mv`를 하는 경우는 작업\n디렉토리에서만 지워지거나 변경되므로, `git rm` 및 `git mv` 명령어를 이용해\n파일의 삭제나 변경을 Staging area에 넣은 뒤 커밋까지 완료해야지 Git 저장소에서\n파일이 삭제되거나 이름이 변경된다.\n\n## 7 커밋 기록 조회\n\n`git log` 명령어를 실행하면 현재 브랜치를 기준으로 지금까지의 커밋 기록를\n시간순으로 출력한다.\n```\n$ git log\ncommit 5175e4cd097c06ee6dead88ba9ed4044c9b22a2b (HEAD -> master)\nAuthor: Alice <alice@mail.com>\nDate:   Tue Jun 19 23:13:00 2018 +0900\n\n    statgpu tutorial\n\ncommit ca82a6dff817ec66f44342007202690a93763949 (origin/master, origin/HEAD)\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n    changed the verison number\n\ncommit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Sat Mar 15 16:40:33 2008 -0700\n\n    removed unnecessary test code\n\ncommit a11bef06a3f659402fe7563abf99ad00de2209e6\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Sat Mar 15 10:31:28 2008 -0700\n\n    first commit\n```\n\n## 8 원격 저장소의 사용\n\n원격 저장소는 인터넷이나 네트워크 어딘가에 있는 저장소를 말하며, 보통\n[GitLab]이나 [GitHub] 같은 사이트에 원격 저장소를 많이 만든다. 다른 사람들과\n협업하기 위해서는 원격 저장소의 사용이 필수불가결하다.\n\n`git remote` 명령으로 현재 프로젝트에 등록된 원격 저장소를 확인할 수 있다. 만일\n저장소가 clone된 저장소였다면 origin이라는 원격 저장소가 자동으로 등록되기\n때문에 origin이라는 이름을 볼 수 있다. 만일 등록된 원격 저장소가 없는 경우는\n`git remote add` 명령어를 이용하여 원격 저장소를 등록할 수 있다.\n```bash\n$ cd /tmp/cloned\n$ git remote -v\norigin  https://github.com/schacon/simplegit-progit (fetch)\norigin  https://github.com/schacon/simplegit-progit (push)\n$ git remote add tmp https://gitlab.com/alice/tutorial\n$ git remote -v\norigin  https://github.com/schacon/simplegit-progit (fetch)\norigin  https://github.com/schacon/simplegit-progit (push)\ntmp     https://gitlab.com/alice/tutorial (fetch)\ntmp     https://gitlab.com/alice/tutorial (push)\n```\n\n등록된 원격 저장소는 `git remote rename`으로 이름을 바꾸거나 `git remote\nrm`으로 제거할 수 있다.\n```bash\n$ git remote rename tmp temp\n$ git remote -v\norigin  https://github.com/schacon/simplegit-progit (fetch)\norigin  https://github.com/schacon/simplegit-progit (push)\ntemp    https://gitlab.com/alice/tutorial (fetch)\ntemp    https://gitlab.com/alice/tutorial (push)\n$ git remote rm temp\n$ git remote -v\norigin  https://github.com/schacon/simplegit-progit (fetch)\norigin  https://github.com/schacon/simplegit-progit (push)\n```\n\n원격 저장소에서 데이터를 가져오려면 `git fetch` 명령어를 실행하면 되는데,\n로컬에는 없지만 원격 저장소에는 있는 데이터를 모두 가져온다. 그러면 리모트\n저장소의 모든 브랜치를 로컬에서 접근할 수 있어서 언제든지 merge를 하거나 내용을\n살펴볼 수 있다. `git pull` 명령은 원격 저장소에서 데이터를 fetch한 다음\n자동으로 로컬 브랜치와 merge시키는 작업도 진행한다.\n\n로컬에서 작업한 커밋들을 원격 저장소로 보내려면 `git push` 명령어를\n사용한다. 예를 들어, origin 원격 저장소로 master 브랜치를 올리고 싶으면\n터미널에서 `git push origin master`를 실행하면 된다. 다만, push를 하기 위해서는\n원격 저장소에 쓰기 권한을 가지고 있어야 하고, 다른 사람이 push한 작업이 원격\n저장소에 있다면 로컬로 가져와서 merge를 먼저 한 뒤에 push를 해야한다.\n\n## 9 고오급 기능들: branch, merge, rebase, stash, ...\n\n앞서 소개한 기능들은 Git의 매우 기초적인 기능들로, 이 정도만 알아도 혼자서\n간단한 프로젝트의 버전 관리 정도는 할 수 있을것으로 여겨진다.\n\n다만, 다른 사람들과 협업을 하거나, 혹은 다양한 버전의 소스코드를 동시에\n다루고자 할 때는 기초적인 기능들로는 많이 부족하다. 이를 효율적으로 다루기\n위해서는 Git의 여러 고급기능들에 익숙해져야하며, 특히 엄청나게 막강한 branch\n기능 및 [GitFlow] 같은 branching model에 익숙해 지는것이 필수이다. 중요한\n기능이지만 꽤 방대한 분량이기에, 이를 매뉴얼에서 마저 소개하기 보다는 [Pro Git]\n같은 다른 레퍼런스를 통해서 익히는 것을 권한다.\n\n\n"},{"fields":{"slug":"/docs/statgpu/linux/ssh/","title":"서버 접속: SSH"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - programming\n  - ssh\n  - manual\n---\n\n# 서버 접속: SSH\n\n일반적으로 리눅스 서버에 접속할 때는 SSH를 이용한다. SSH는 Secure SHell의 약자로, 원격 시스템에서 안전하게 명령을 실행시키기 위한 프로그램 혹은 통신 프로토콜을 뜻한다. 만일 서버에 접속 할 수 있는 계정을 가지고 있고 네트워크로 잘 연결된 상태라면, 언제든 SSH를 이용하여 서버에 접속하여 작업을 할 수 있다.\n\nSSH는 서버 접속 뿐만 아니라 다양한 기능들을 가지고 있는데, 자세한 내용은 뒤에 리눅스 관련 팁들을 서술할 때 마저 다루기로 한다.\n\n윈도우에서는 [PuTTy]를 이용하여 접속할 수 있으며, 맥이나 리눅스에서는 터미널의 `ssh` 명령어를 이용하여 다음과 같이 접속이 가능하다:\n\n```bash\n# 참고: 특별한 말이 없다면 `#` 뒤에 나오는 내용들은 주석(comment)이다.\n\n# 사용법: ssh -p [PORT] [USER]@[SERVER]\n\n# 클라이언트에서 입력하는 명령어. 앞에 `~ `는 제외하고 입력.\n~ ssh -p 2222 alice@server.address.com\nalice@server.address.com password:\n# 서버에서 입력하는 명령어. 앞에 `$ `는 제외하고 입력. 명령의 결과는 터미널로 출력된다.\n$ whoami\nalice\n```\n\n성공적으로 접속이 되었다면 터미널 창이 뜰 것이다. 이 터미널에 입력되는 모든 명령들은 서버의 쉘로 전송되어 실행된다.\n\n\n"},{"fields":{"slug":"/docs/statgpu/linux/useful/","title":"기타 유용한 팁들"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - ssh\n  - programming\n  - manual\n---\n\n# 기타 유용한 팁들\n\n## 1 SSH의 다른 기능들\n\n앞서 서버에 접속하기 위한 방법으로 SSH를 다뤘었는데, SSH는 단순히 서버에\n명령어를 보내는 기능 외에 여러 다양하고 유용한 기능들을 가지고 있다. 주로\n암호화된 보안 접속 위에서 안전하게 서버와 통신한다는 점을 바탕으로 많은\n기능들이 개발되었는데, 여기서는 그 중 자주 쓰이는 파일 전송과 SSH 터널링에 대해\n다룬다.\n\n### 1.1 파일 전송\n\nSSH를 이용한 파일 전송 규격인 SCP가 개발되어 있으며, 이를 기반으로 SFTP나 rsync\n등 다양한 전송 규격들이 구현되어 있다. 이러한 전송 규격들을 이용해 클라이언트와\n서버 사이 쉽게 파일들을 주고 받을 수 있다.\n\nSSH를 이용한 파일 전송 중에서 가장 쉬운 방법 중 하나는 [FileZilla]로 SFTP를\n사용하는 것이다. FileZilla는 가장 대중적인 FTP 클라이언트 중 하나로, 직관적인\nGUI 기반이기 때문에 쉽게 사용할 수 있다. FileZilla로 SFTP를 쓰기 위해서는 SSH로\n접속할 때와 동일한 주소, 포트, 계정을 이용하여 접속하면 된다.\n\n### 1.2 SSH 터널링\n\nSSH 터널링이란 SSH 접속을 다른 프로그램이 사용할수 있도록 포트 포워딩해주는\n것을 말한다. SSH 터널링의 효과는 두 가지인데 (i) 암호화 접속을 사용하지 않는\n프토로콜을 SSH로 암호화시켜 보다 안전하게 사용하도록 하며 (ii) 방화벽으로\n외부 포트를 막아놓은 경우 SSH 터널링을 이용하여 이를 우회할 수 있다.\n\n간단한 예를 들어보자. 먼저 서버에서 다음과 같은 프로그램을 실행하자[^useful-1].\n\n[^useful-1]: Python3의 내장 모듈 중 하나인데, 현재 디렉토리의 파일들을 보여주는\n    간단한 웹 서버이다. 필자는 (진짜 귀찮을때) 임시 파일 전송용으로 써먹는데\n    꽤나 편하다.\n\n```bash\n~ ssh -p 2222 alice@server.address.com\n$ python3 -m http.server\nServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...\n```\n\n이제 웹 브라우저를 열어서 `http://server.address.com:8000`으로 접속을\n해보자. 만일 서버에서 8000번 포트를 방화벽으로 막은 상황이면 접속시 페이지가\n뜨지 않는 것을 확인할 수 있다. 방화벽으로 막지 않아 페이지가 뜬 경우도 연결이\n전혀 암호화되지 않은 상태로, 단순한 웹 서버가 아니라 개인정보나 비밀번호를\n주고받는 서비스를 이용하고자 하는 경우면 이는 심각한 보안 결함점이 될 수 있다.\n\nSSH 터널링을 이용하여 이를 해결해보자. SSH로 접속을 할 때 `-L` 플래그를 다음과\n같이 추가한다:\n```bash\n~ ssh -p 2222 alice@server.address.com -L 9000:localhost:8000\n$ python3 -m http.server\nServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...\n```\nSSH 접속을 *끊지 않은 채로*, `http://server.address.com:8000` *대신*\n`http://localhost:9000`로 접속하면 웹 서버가 정상적으로 뜨는 것을 확인할 수\n있다. 이것이 터널링의 효과인데, 클라이언트의 9000번 포트로 들어온 모든 접속이\n서버의 localhost 8000번 포트로 포워딩되기 때문이다. 포워딩 중간의 모든 과정은\n(이미 연결된) SSH 프토토콜 위에서 진행되므로 암호화가 된 상태이며 방화벽도\n우회할 수 있는 것이다.\n\n## 2 터미널 세션 관리: tmux\n\nSSH 터미널의 경우, 접속을 종료하거나 접속이 끊기면 그 순간 터미널에서 진행되고\n있던 모든 작업들이 *강제로 종료되게* 된다. 이를 방지하기 위한 하나의 방법으로\n`tmux`를 사용하는 법이 있다.\n\n다음 명령어를 입력하면 새 tmux 세션을 생성한다. tmux 세션들은 터미널 아래에\n초록색 줄이 보이므로 쉽게 구분할 수 있다.\n```bash\n$ tmux new -s session-name\n```\n\ntmux 세션 창에서, `ctrl-b d`를 입력하면 세션이 detach되게 된다. detach된 세션은\n완전히 종료된 것이 아니라 background에서 계속 실행되고 있는 상태이므로, 다음\n명령어를 통해 다시 attach 할 수 있다:\n```bash\n$ tmux attach -t session-name\n```\n이렇게 tmux에서 관리되는 세션은 중간에 터미널 접속이 끊기더라도 그래도\n유지된다. 세션을 완전히 종료하고 싶은 경우는 tmux 세션에서 `exit` 명령어로 tmux\n세션의 모든 쉘을 종료시키면 된다.\n\n필자의 경우 아예 `.bashrc` 파일 마지막에 다음과 같은 스크립트를 추가했다.\nSSH 접속을 할 때마다 자동적으로 기존 작업하던 tmux 세션을 attach하며, 기존\n세션이 없는 경우에는 새로 세션을 만드는 스크립트이다.\n```.bash\n# $HOME/.bashrc 파일 내용 중 일부\nif [[ \"$TERM\" != \"dumb\" && -z \"$TMUX\" && -n \"$SSH_TTY\" ]]; then\n  if tmux has-session -t ssh 2>/dev/null; then\n    exec tmux -2 attach-session -t ssh\n  else\n    exec tmux -2 new-session -s ssh\n  fi\nfi\n```\n\n한 가지 불편한 점은, tmux 세션에서는 마우스 휠을 이용해 쉘의 스크롤을 이동할 수\n없다. 대신 copy mode로 들어간 다음 화살표키나 `PageUp`, `PageDown` 키를\n이용하여 스크롤을 이동할 수 있다. Copy mode는 `ctrl-b [`로 진입할 수 있으며,\n`ESC` 키를 이용하여 빠져나올 수 있다.\n\ntmux는 뿐만 아니라 터미널 창 분할이나 공유 등 다양한 기능을 가지고 있다. 자세한\n사항은 man page나 구글링으로 찾아보길 바란다.\n\n## 3 스마트폰으로 알림 전송: Pushover\n\n서버에서 언제 끝날지 감이 잡히지 않는 프로그램을 돌리고자 할 때가 자주\n있을텐데, 이 경우 서버에서 실행된 프로그램이 언제 종료되었는지, 혹은 버그가\n발생했는지 아니면 성공적으로 끝마쳤는지 등이 우리의 주 관심사이다. 이를 서버에\n매번 들어가서 확인하는 번거로운 방식 대신 서버에 특정 이벤트가 발생하였을 때\n메일이나 알림 등으로 알리는 것이 훨씬 편한 방식일 것이다. [Pushover]를 사용하면\n서버에서 스마트폰으로 쉽게 알림을 전송할 수 있다. 거의 모든 프로그래밍 언어의\nAPI를 가지고 있어 쉽게 사용할 수 있으나 알림을 받는 기기 하나당 $5를 지불하고\n앱을 구매해야 한다. 자세한 내용은 공식 홈페이지를 확인.\n\n\n"},{"fields":{"slug":"/docs/statgpu/linux/vim/","title":"텍스트 에디터: Vim"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - programming\n  - manual\n---\n\n# 텍스트 에디터: Vim\n\n서버 환경에서 코드(혹은 문서)를 작성 및 수정 할 때는 텍스트 에디터를 사용한다. 리눅스에서 널리 쓰이는 텍스트 에디터로는 Vi, Emacs, Nano 등이 있다. Vim은 Vi의 변종판인 `Vi improved`를 지칭하며 여기서는 Vim의 간단한 사용법에 대해 설명한다.\n\n## 1 Vim의 실행\n\n터미널에서 다음과 같이 입력하면 Vim을 실행할 수 있다.\n```bash\n$ vim\n```\n일반적으로는 `vi`만 입력해도 alias에 의해 `vim`이 실행된다.\n\n직접 파일을 생성하고자 할 때는\n```bash\n$ vi filename\n```\n을 실행하면 된다. 파일이 없는 경우에는 해당 파일명을 갖는 파일이 생성되고, 있는\n경우에는 확인 및 수정이 가능하다. 단, vi를 사용할 때는 실제로 확장자명을\n명시해야 한다. 가령, 다음과 같이 텍스트 파일 `hello.txt`를 작성할 수 있다.\n```bash\n$ vi hello.txt\n```\n\n## 2 Vim의 주요 모드\n\n위의 방법으로 Vim을 실행하면 갑자기 대부분의 키가 작동하지 않는 상태가 된다.[^vim-1] 이와 같은 현상이 발생하는 이유는 Vim에는 다양한 모드가 있기 때문이다.\n\n[^vim-1]: 두렵다면 Esc 키를 누르고 `:q!` 를 눌러서 Vim을 나갈 수 있다. 그러나 필자는 두려움을 이겨내는 자가 진정으로 용기있는 자라 생각한다.\n\nVim에는 일반(Normal), 입력(Insert), 비주얼(Visual), 명령어(Command)의 네 가지 주요 모드가 있다. Vim을 처음 실행하면 일반 모드 상태이다. 여기서 i(insert의 줄임)키를 누르면 텍스트를 입력할 수 있는 입력 모드가 된다. Esc 키를 누르면 다시 일반 모드로 돌아간다. 일반 모두에서 v키를 누르면 블럭 등을 지정할 수 있는 비주얼 모드가 된다. Vim 에서는 화면의 제일 밑줄에 -- INSERT --, -- VISUAL -- 와 같이 현재 모드를 알려준다.\n\n일반 모드인 상태에서 :를 누르면 명령어(Command) 모드가 된다. 모드 상태를 보여주던 제일 밑줄에서 :다음에 커서가 놓이면서 명령어를 기다리는 것을 볼 수 있다. 각종 명령어를 사용하여 거의 모든 환경설정과 파일 열기(e; edit)/저장(w; write)과 종료(q; quit) 등의 작업이 가능하고 컴파일 등 외부 쉘 명령까지 실행할 수 있다.\n\n![VIM modes](../img/vim-modes.png)\n\n## 3 Vim의 대표적인 키\n\n다음은 Vim에서 주로 사용하게 될 키들이다. 각 제목의 괄호 안은 실행 가능한 모드를 의미한다.\n\n### 3.1 이동 (일반 모드, 비주얼 모드)\n\n코드를 작성할 때 코드의 다른 부분으로 이동하는 것은 매우 필수적인 기능이다. Vim에서는 화살표 모양의 방향키를 이용하는 것 보다 훨씬 세련된 이동 관련 명령어들을 지원한다.\n\n|   Commands   |   Function   |\n|--------------|--------------|\n| h | 왼쪽 이동 |\n| j | 아래로 이동 |\n| k | 위로 이동 |\n| l | 오른쪽 이동 |\n| w | 다음 단어 시작으로 이동 |\n| 0 | 행의 시작으로 이동 |\n| $ | 행의 끝으로 이동 |\n| :`n` | n번째 줄로 이동 |\n| gg | 문서 첫 행으로 이동 |\n| G | 문서 마지막 행으로 이동 |\n\n이 외에도, Vim에서는 다양한 이동 관련 명령어들을 지원한다. 방향이동과 관련된 키를 보면 알겠지만 과거에는 방향키가 없었기에 키보드 위의 적당한 위치에 방향키를 맵핑하여 사용했다. 물론 최근의 Vim은 마우스 클릭과 방향키 이동을 모두 지원한다. 그러나 실제로 Vim을 사용하다 보면 멀리 떨어져 있는 마우스나방향키에 손을 뻗는 것이 귀찮게 느껴질 것이고 키에 익숙해지기만 한다면 위의 방향키들을 사용하는 것이 훨씬 편하게 느껴질 것이다.\n\n### 3.2 텍스트 삽입 및 추가 (일반 모드)\n\n위에서는 `i`키를 누르면 편집 모드로 들어갈 수 있다고 했지만, 실제로 편집 모드에 들어갈 수 있는 키는 여러가지가 있다. 이들은 모두 그 기능이 다르다.\n\n|   Commands   |   Function   |\n|--------------|--------------|\n| i | 커서 앞에 추가 |\n| a | 커서 뒤에 추가 |\n| s | 한 글자 삭제하고 삽입모드 시작 |\n| o | 현재 행 아래에 새 행 추가 |\n| O | 현재 행 위에 새 행 추가 |\n| Esc | (입력 모드에서) 일반 모드로 진입 |\n\n### 3.3 편집 (일반 모드, 비주얼 모드)\n\n편집 관련 명령어들은 코드를 작성할 때 가장 요긴하게 쓰일 모드일 것이다. 옛 말에 이런 말도 있지 않은가\n\n> 복붙은 인간의 가장 위대한 발명품이다.\n\n그러나 안타깝게도, Vim의 복붙은 윈도우나 맥의 그것과는 사뭇 다르다. Vim에서 복붙을 비롯한 여러 명령어들은 다음과 같다.\n\n|   Commands   |   Function   |\n|--------------|--------------|\n| r | 한 글자 바꾸기 |\n| u | 실행 취소(undo) |\n| Ctrl + r | 다시 실행(redo) |\n| y | 선택 영역 복사(yank) |\n| yy | 행 복사 |\n| p | 커서 뒤에 붙여넣기(paste) |\n| P | 커서 앞에 붙여넣기 |\n| dd | 행 잘라내기 |\n| x | (선택 영역) 잘라내기 |\n| d(motion) | (선택 영역) Motion 잘라내기 |\n| dd | 행 잘라내기 |\n\n편집 관련 키들은 Vim의 꽃이라고 할 수 있는 **함수형 명령**을 지원한다. 이는 여러 개의 명령어를 입력했을 때, 합성함수처럼 기능을 사용할 수 있음을 의미한다. 대표적으로 `n + commands`가 있는데, 이는 해당 명령을 $n$번 반복하는 것으로 해석된다. 예를 들어 `5dd`는 `dd를 다섯 번 반복`, 즉, 5개의 행을 잘라내라는 명령이 된다. 비슷하게 `5dk`는 k가 위로, d가 motion을 input으로 받아 해당 부분을 잘라내는 명령을 의미하므로, `위로 5개의 행을 잘라내라`는 명령이 된다. Vim에서는 이와 같은 특징을 이용해 숫자와 방향키를 이용하여 문서 내를 자유자재로 돌아다니거나 빠른 속도로 코드를 편집할 수 있다.\n\n### 3.4 텍스트 선택 (비주얼 모드)\n\n비주얼 모드는 선택 모드라고도 불리운다. 이는 비주얼 모드가 마우스의 드래그와 비슷하게 요소들을 블록으로 묶어 편집할 수 있는 기능을 제공하는 모드라 그렇다. 비주얼 모드와 관련된 명령어들은 다음과 같다.\n\n|   Commands   |   Function   |\n|--------------|--------------|\n| v | 선택 모드 시작 (방향키로 선택) |\n| V | 행 단위 선택 모드 시작 (방향키로 선택) |\n| Ctrl + v | 블록 단위 선택모드 시작 |\n| Esc | 비주얼 모드 종료 |\n\n### 3.5 찾기, 바꾸기 (일반 모드)\n\n윈도우에서는 `Ctrl + f`, 맥에서는 `Cmd + f`로 문서 내의 특정 문자들을 찾을 수 있다. Vim에서는 언뜻 보면 더 난해하지만, 더 세련된 방식의 찾기와 바꾸기 기능을 지원한다.\n\n|   Commands   |   Function   |\n|--------------|--------------|\n| /pattern | pattern이 나타난 부분 찾기 |\n| n | 다음 찾기 |\n| N | 이전 찾기 |\n| :n,ms/old/new/ | n번째 행부터 m번째 행까지 각 행의 첫 old를 new로 변경 |\n| :%s/old/new/g | 문서 내 모든 old를 new로 변경 |\n| :%s/old/new/gc | 문서 내 모든 old를 하나씩 확인해가며 new로 변경 |\n\n여기서 마지막 부분의 s는 substitute의 약자이다. `:(start),(end)s/old/new/option`라는 명령어는 `start에서 end까지 old를 new로 option대로 바꾼다`를 뜻한다. 이때 start와 end를 모두 생략하고 %를 입력하면 검색 범위가 문서 전체가 되고, option에는 다음과 같은 명령어들을 입력할 수 있다.\n\n* g : global - 한 줄에 패턴이 여러 번 나오면 모두 바꾼다. 지정하지 않으면 첫번째 패턴만 치환\n* i : ignore case - 대소문자 구분을 하지 않는다.\n* c : confirm - 검색된 모든 문자열에 대해서 바꿀지 말지를 물어본다.\n\nVim의 찾기 기능의 특별한 점은 정규표현식을 지원한다는 점인데, 가령 문서 내의 vi 또는 Vi를 모두 지우고 싶을 때는 `:%s/[vV]i//g`를 입력하면 된다! 정규표현식에 대해 더 자세히 공부하고 싶다면 [여기](https://regexone.com/)를 방문하면 된다.\n\n### 3.6 열기, 저장 및 종료 (일반 모드)\n\n문서의 저장, 종료 등과 관련된 명령어는 다음과 같다.\n\n|   Commands   |   Function   |\n|--------------|--------------|\n| :q | 아무런 변경을 하지 않았을 때 종료하기 |\n| :q! | 변경된 내용을 저장하지 않고 강제 종료하기 |\n| :w | 변경된 내용을 저장 |\n| :wq | 저장하고 종료하기 |\n| :wq! | 강제로 저장하고 종료하기 |\n| :x | 저장하고 종료하기(=wq) |\n| :w `filename` | `filename`으로 파일 저장하기 |\n| :e `filename` | `filename` 파일 열기 |\n\n이때 `:x` 의 경우 변동 사항이 없으면 그냥 종료하지만 `:wq`는 항상 저장하고 종료한다는 작은 차이점이 있다. 이 외에도 Vim에는 다양한 명령어들이 있으며 [Vim Cheat Sheet](https://vim.rtorr.com/lang/ko/)에서 확인할 수 있다.\n\n## 4 기타\n\n여기까지 Vim의 간단한(?) 사용법들을 알아보았다. 이 문서를 통해 Vim을 처음 접하는 사람들은 이런 생각을 할 것이다.\n\n> 도대체 내가 왜 이딴 걸 하고 있지?\n\n그러나 Vim이 마냥 불편하고 비효율적이기만 했다면 이렇게 오랜 시간동안 사용될 리는 없었을 것이다. Vim에는 다음과 같은 장점들이 있다.\n\n1. 대부분의 명령어가 키보드 위에 있어, 손가락을 많이 이동하지 않고 작업을 진행할 수 있다.\n2. `.vimrc`파일을 이용해 쉽게 커스터마이징할 수 있다.\n3. 오랜 시간동안 개발된 수많은 플러그인들이 있다. (자동완성 등)\n4. 무엇보다도, **어떤 Unix(Mac 등)나 Linux 시스템에도 vi는 기본적으로 설치되어 있다**. 즉, 많은 환경에서 별다른 환경설정 없이 편집을 진행할 수 있다!\n\n끝으로, 실제로 Vim을 공부하려 한다면 위의 문서들을 일일히 읽고 있는 것 보다는 직접 연습을 하며 익혀보는 것을 강력하게 추천한다. 터미널에 다음을 입력하여 vim의 tutorial을 실행할 수 있다.\n\n```bash\n$ vimtutor\n```\n"},{"fields":{"slug":"/docs/statgpu/statgpu/module/","title":"module 사용법"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - server\n  - programming\n  - manual\n  - linux\n---\n\n# `module` 사용법\n\n`module`은 계산서버에 설치된 각종 컴파일러, 라이브러리, 주요 프로그램에 관련된\n환경 설정을 쉽게 할 수 있도록 도와주는 보조 프로그램이다. 요컨대, 여러분이\n서버에 설치된 어떤 프로그램을 사용하고자 할 때, `module` 명령어를 이용하면\n손쉽게 그 프로그램을 사용하기 위한 준비를 마칠 수 있다. 예를 들어, C++\n컴파일러로 g++ 대신 Intel C++을 사용하고자 한다거나, MPI 인터페이스로 OpenMPI\n대신 MVAPICH를 사용하려 할 때 일일이 환경설정을 손으로 수정할 필요 없이\n`module` 명령어로 쉽게 쉘 환경을 변경할 수 있다.\n\n`module`의 경우 man page는 없지만 쉘에서 `module`을 아무런 인자 없이 실행하면\n사용가능한 모든 명령어들을 보여준다. 매뉴얼에서는 그 중 자주 사용되는 명령어만\n다루도록 한다.\n\n## 1 `module available`: 사용가능한 모듈을 확인\n```bash\n$ module available\n---------------------- /opt/ohpc/pub/moduledeps/gnu7-openmpi ----------------------\n   adios/1.11.0    mpiP/3.4.1              petsc/3.7.6        scorep/3.0\n   boost/1.63.0    mumps/5.1.1             phdf5/1.10.0       sionlib/1.7.1\n   fftw/3.3.6      netcdf-cxx/4.3.0        scalapack/2.0.2    superlu_dist/4.2\n   hypre/2.11.1    netcdf-fortran/4.4.4    scalasca/2.3.1     tau/2.26.1\n   imb/4.1         netcdf/4.4.1.1          scipy/0.19.0       trilinos/12.10.1\n\n-------------------------- /opt/ohpc/pub/moduledeps/gnu7 --------------------------\n   R/3.3.3     (L)    metis/5.1.0     ocr/1.0.1              superlu/5.2.1\n   gsl/2.3            mpich/3.2       openblas/0.2.19 (L)\n   hdf5/1.10.0        mvapich2/2.2    openmpi/1.10.7  (L)\n   impi/2017.3        numpy/1.12.1    pdtoolkit/3.23\n\n---------------------------- /opt/ohpc/pub/modulefiles ----------------------------\n   EasyBuild/3.2.1             example1/1.0            prun/1.1        (L)\n   autotools          (L)      gnu/5.4.0               python/3.5.1\n   clustershell/1.7.3          gnu7/7.1.0       (L)    singularity/2.3\n   cuda/7.0                    intel/17.0.4.196        valgrind/3.12.0\n   cuda/7.5                    ohpc             (L)\n   cuda/8.0           (L,D)    papi/5.5.1\n\n  Where:\n   D:  Default Module\n   L:  Module is loaded\n\nUse \"module spider\" to find all possible modules.\nUse \"module keyword key1 key2 ...\" to search for all possible modules matching any of the \"keys\".\n```\n\n## 2 `module list`: 현재 로드된 모듈을 확인\n```bash\n# 학과 계산서버는 다음 모듈들을 기본적으로 로드한다\n$ module list\nCurrently Loaded Modules:\n  1) autotools   3) gnu7/7.1.0       5) openblas/0.2.19   7) cuda/8.0\n  2) prun/1.1    4) openmpi/1.10.7   6) R/3.3.3           8) ohpc\n```\n\n## 3 `module load`, `module rm`: 모듈을 로드하거나 제거\n```bash\n$ which python3\npython3 not found\n$ module load python/3.5.1\n$ module list\nCurrently Loaded Modules:\n  1) autotools    4) openmpi/1.10.7    7) cuda/8.0\n  2) prun/1.1     5) openblas/0.2.19   8) ohpc\n  3) gnu7/7.1.0   6) R/3.3.3           9) python/3.5.1\n$ which python3\n/opt/ohpc/pub/libs/python/3.5.1/bin/python3\n$ module rm python/3.5.1\n$ which python3\npython3 not found\n```\n\n## 4 `module purge`: 로드된 모든 모듈을 제거\n```bash\n$ module purge\n$ module list\nNo modules loaded\n```\n\n\n"},{"fields":{"slug":"/docs/statgpu/statgpu/slurm/","title":"Slurm 사용법"},"frontmatter":{"draft":false},"rawBody":"---\ntags:\n  - programming\n  - server\n  - manual\n---\n\n# Slurm 사용법\n\n학과 계산서버에 접속하였을 때, 접속한 서버는 master 노드로, 실제 계산과정이\n이루어지는 worker 노드가 아니다. 실제 CPU나 GPU를 사용한 작업을 하기 위해서는\n하는 작업을 명시한 다음 이를 master 노드에 요청하여 master 노드가 이를 다른\nworker 노드로 보내는 과정을 거쳐야 한다. 학과 클러스터는 [slurm]이라는 스케쥴러\n프로그램을 사용하여 이를 관리하고 있다.\n\nSlurm의 기본 명령어들에는 다음 명령어들이 있다.\n\n| 명령어     | 내용                        |\n|------------|-----------------------------|\n| `srun`     | 작업 제출 (interactive)     |\n| `sbatch`   | 작업 제출 (non-interactive) |\n| `scancel`  | 제출한 작업 취소            |\n| `sinfo`    | 노드 정보 확인              |\n| `squeue`   | 제출된 작업들 확인          |\n| `scontrol` | 작업의 자세한 상태 확인     |\n| `smap`     | 작업 상태 및 노드 상태 확인 |\n\n## 1 `sbatch`: 작업 제출\n\n`sbatch` 프로그램은 스크립트 파일을 받아 worker의 자원을 할당받고 할당받은\n노드에서 작업을 실행하는 역할을 한다. `sbatch`에 요청하는 스크립트 파일은 일반\n`bash` 스크립트 파일과 동일하나, `#SBATCH `로 시작하는 `bash` 주석에[^slurm-1]\n`sbatch`와 관련된 설정을 명시할 수 있다. 보통은 할당받을 자원(CPU, GPU 등)을\n명시하는 목적으로 쓰인다. 다음은 스크립트 예제인데, 앞에 여러 설정들을\n적어놓고, worker 노드에서 실행될 코드를 아래에 적어 놓은것을 확인할 수 있다.\n\n[^slurm-1]: `bash`에서는 주석 처리되어 아무런 기능을 하지 않으나 `sbatch`는 이런\n    라인들을 해석한다. 앞에 `#`과 `SBATCH` 사이 띄어쓰기가 없고, `SBATCH` 바로\n    뒤에는 띄어쓰기가 있음에 유의하라.\n\n```{.bash .numberLines}\n#!/bin/bash\n\n#SBATCH --mail-user=address@mail.com # 알림을 받을 메일 주소\n#SBATCH -J foobar  # 작업 이름\n#SBATCH -t 0-00:30:00  # 최대 작업 시간; 이 시간이 지나면 강제 종료된다. 2일이 최대.\n#SBATCH --partition gpu  # 작업 파티션 이름; cpu 또는 gpu\n#SBATCH --nodes=1  # 할당받을 전체 노드 개수; 현재 4대의 worker 노드가 존재.\n#SBATCH --ntasks=1  # 실행할 전체 작업의 개수; 적은 개수만큼 동일한 작업을 실행한다.\n#SBATCH --cpus-per-task=2  # 작업 하나마다 할당할 cpu의 개수\n#SBATCH --gres=gpu:2  # 노드마다 할당받을 gpu 개수; gpu 파티션에서만 사용\n\n# 아래는 실제 실행되는 쉘 스크립트 코드\n# 이 때 SLURM_ 으로 시작되는 환경변수들을 사용할 수 있다. 자세한 것은 공식 매뉴얼 참조.\necho \"===== BEGIN $SLURM_JOB_NAME ($SLURM_JOB_ID) AT $(date) =====\"\necho 'from tensorflow.python.client import device_lib; print(device_lib.list_local_devices())' | python\necho \"==== FINISH $SLURM_JOB_NAME ($SLURM_JOB_ID) AT $(date) =====\"\n```\n\n위와 같이 `example.sh` 스크립트 파일을 작성하였으면 다음과 같이 작업을 실행할\n것을 요청할 수 있다. 작업을 요청하면 바로 시작하는 경우도 있으나, 만일\n계산서버의 모든 자원이 사용중이여서 작업을 할 수 없는 경우는 다른 작업이\n끝나기를 기다렸다가 작업을 시작한다.\n```bash\n$ sbatch example.sh\nSubmitted batch job 5174\n```\n\n모든 `sbatch` 작업의 출력은 `slurm-####.out` 파일에 저장된다.\n```bash\n$ cat slurm-5174.log\n===== BEGIN foobar (5174) AT Mon Mar 5 16:08:21 KST 2018 =====\n/device:GPU:0\n/device:GPU:1\n==== FINISH foobar (5174) AT Mon Mar 5 16:08:24 KST 2018 =====\n```\n\n### 1.1 자원 할당과 관련하여\n\n현재 계산서버에는 4개의 worker 노드가 있으며, worker 노드 하나당 cpu 코어 40개,\ngpu 2개를 가지고 있다. 따라서 `sbatch`에서 필요한 자원을 할당 받을 때, 이 점을\n고려하여 필요한 만큼 적으면 된다. gpu의 사용은 gpu 파티션에서만 가능하며,\ngpu 파티션은 cpu를 worker 하나 당 최대 2개밖에 할당 받을수 없음을 유의하라.\n작업 시간은 cpu, gpu 상관없이 한 번에 최대 2일만 할당됨을 유의하라.\n\n어떤 식으로 자원을 할당 받아야 하는지는 하고자 하는 작업의 성격에 따라 다를 수\n있다. 요컨대 똑같이 cpu 코어 40개를 받는다 하여도 하나의 노드에서 하나의\n작업을 실행하고 거기에 40개를 모두 배정할 수도, 4개의 노드에서 4개의 작업을\n실행해 작업 하나에 10개씩 배정할 수도, 혹은 2개의 노드에서 40개 작업을 실행하고\n작업 하나에 하나씩 배정할 수도 있다. 이는 전적으로 여러분의 선택이므로, 자신이\n짠 프로그램의 성질을 잘 고려하여 요령껏 자원을 할당받도록 하자.\n\n자원을 할당 받을 때 참고가 될만한 use case들은 뒤에서 다루도록 한다.\n\n## 2 `scontrol`: 제출된 작업의 상세정보 조회\n```bash\n$ scontrol show job 5174\n```\n\n## 3 `squeue`: 제출된 작업 목록 조회\n\n```bash\n$ squeue\n             JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)\n              5174       gpu   foobar bayesian PD       0:00      1 (Resources)\n```\n\n## 4 `scancel`: 제출한 작업 취소\n\n```bash\n$ scancel 5174\n$ squeue\n             JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)\n```\n\n## 5 `sinfo`: Worker 노드 및 파티션 정보 조회\n\n```bash\n$ sinfo\nPARTITION AVAIL  TIMELIMIT  NODES  STATE NODELIST\ncpu*         up 2-00:00:00      4   idle n[1-4]\ngpu          up 2-00:00:00      4   idle n[1-4]\n```\n\n\n"},{"fields":{"slug":"/docs/statgpu/statgpu/usecase/","title":"Use cases"},"frontmatter":{"draft":false},"rawBody":"# Use cases\n#programming #example\n\n이 장에서는 실제로 어떤 식으로 `slurm`을 이용하여 자원을 할당\n받아야 하는지 여러 간단한 use case를 통해 알아보도록 한다.[^usecase-1]\n\n[^usecase-1]: 물론 여기 있는 예시들은 *매우 간단한* 예시들만을 다뤘으며, 여기\n    있는 예시들을 결합하거나 혹은 예시로 들지 않은 다른 구조를 사용하는 등\n    멀티코어를 이용하는 방법들은 다양하다. 매뉴얼의 예시 이상의 사용법은 직접\n    연구를 하여 사용법을 익히기를 권장한다.\n\n## 1 `sbatch` Script Using Multithreading\n\n하나의 작업을 실행하고 그 작업을 여러 Thread가 진행하는 경우로, OpenBLAS나\nIntel MKL 같은 멀티코어 수치해석 라이브러리를 사용하는 경우가 여기에 해당한다.\n일반 컴퓨터에서 돌아가는 프로그램 소스 코드를 특별히 수정하지 않아도 서버\n자원들을 모두 활용할 수 있으나, 하나의 노드밖에 쓰지 못한다.\n\n### 1.1 + OpenBLAS\n#blas\n\n다음과 같은 방식으로 `sbatch` 스크립트를 작성한다.\n```{.bash .numberLines}\n#!/bin/bash\n#SBATCH --partition cpu\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=38\n\n# 환경변수 설정: OpenBLAS가 사용할 CPU 코어 개수를 정해줌\nexport OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK\nexport MKL_NUM_THREADS=$SLURM_CPUS_PER_TASK\n\n# 필요한 모듈 로드\nmodule purge; module load gnu7 openblas R\n\n# 실행\nRscript script.R\n```\n\n### 1.2 Python + Intel MKL\n#blas\n\n다음과 같은 방식으로 `sbatch` 스크립트를 작성한다.\n```{.bash .numberLines}\n#!/bin/bash\n#SBATCH --partition cpu\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=38\n\n# 환경변수 설정: Intel MKL이 사용할 CPU 코어 개수를 정해줌\nexport OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK\nexport MKL_NUM_THREADS=$SLURM_CPUS_PER_TASK\n\n# 필요한 모듈 로드\nmodule purge; module load intel numpy\n\n# 실행\npython script.R\n```\n\n## 2 `sbatch` Script Using MPI\n\n여러 개의 작업을 실행하고 각각의 작업들이 서로 MPI 규격으로 자료를 주고받고\n통신하면서 작업을 진행하는 경우이다. MPI를 이용하기 위해서는 특정 MPI 구현체의\nAPI를 이용하여 새로 프로그램을 작성해야 하나, 여러 노드의 자원들을 활용할 수 있다.\n\n### 2.1 + OpenMPI\n\n다음과 같은 방식으로 `sbatch` 스크립트를 작성한다.\n```{.bash .numberLines}\n#!/bin/bash\n#SBATCH --partition cpu\n#SBATCH --ntasks=150\n\n# 필요한 모듈 로드\nmodule purge; module load gnu7 R openmpi\n\n# 실행\nRscript script.R\n```\n\n### 2.2 Python + OpenMPI\n\n다음과 같은 방식으로 `sbatch` 스크립트를 작성한다.\n```{.bash .numberLines}\n#!/bin/bash\n#SBATCH --partition cpu\n#SBATCH --ntasks=150\n\n# 필요한 모듈 로드\nmodule purge; module load gnu7 openmpi numpy scipy\n\n# 실행\npython script.py\n```\n\n## 3 `sbatch` Script Using GPU\n#gpu\n\nGPU를 사용하고자 하는 경우이다.\n\n### 3.1 Python + Tensorflow\n\n다음과 같은 방식으로 `sbatch` 스크립트를 작성한다.\n```{.bash .numberLines}\n#!/bin/bash\n#SBATCH --partition gpu\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=2\n#SBATCH --gres=gpu:1\n\n# 필요한 모듈 로드\nmodule purge; module load cuda\n\n# 실행\npython script.py\n```\n\n## 4 Interactive Job With `srun`\n\n자료분석이나 기계학습 분야에서는 위와 같이 스크립트 파일을 작성하기 보다는\ninteractive한 작업 환경을 구축하는 것이 더 자연스럽고 효율적이다. `slurm`의\n`srun`을 이용하면 worker 노드로부터 자원을 할당받아 interactive하게 작업을 할\n수 있다. 구체적인 설정은 `sbatch`의 것과 동일하다.\n\n```bash\n# CPU 파티션의 한 노드로부터 32개 코어를 이틀간 할당받은 뒤 bash를 실행\n$ srun -N 1 -t 2-00:00:00 -I --pty -p cpu -c 32 /usr/bin/bash\n# GPU 파티션의 한 노드로부터 1개 GPU를 이틀간 할당받은 뒤 bash를 실행\n$ srun -N 1 -t 2-00:00:00 -I --pty -p gpu --gres=gpu:1 /usr/bin/bash\n```\n\n위와 같이 자원을 할당받으면 각 worker 노드에서 bash가 실행된 모습을 확인할 수\n있으며, 평소 리눅스 서버에서 작업을 하듯 자유롭게 작업을 할 수 있다.\n\n작업의 제출은 Ctrl+c로 취소할 수 있으며 쉘이 종료되면 작업도 함께 종료되므로 앞서 소개한\ntmux와 함께 사용할 것을 권장한다. 또한, `srun`으로 실행한 프로그램에 SSH 터널링으로 \n접속을 원할 때는 해당 노드에 다시 터널을 열어주어야 한다. \n\n예를 들어, srun을 통해 n1 노드를 할당받고 8888번 포트로 주피터 노트북을 실행했다고 하자.\n로컬에서 노트북에 접속하기 위해서는 다음과 같은 SSH 터널링을 이용할 수 있다.\n```bash\n~ ssh -t -t -p 2222 alice@server.address.com -L 8888:localhost:8888 ssh n1 -L 8888:localhost:8888\n```\n\n\n## 5 Slurm APIs\n\n`srun`을 이용하거나 `sbatch` 스크립트를 작성하는 대신 프로그램 자체에서 slurm과\n통신하는 패키지를 사용할 수도 있다. 이 때는 명시적으로 `sbatch`를 사용하는\n대신, master 노드에 패키지를 설치하고 실행하면 된다. R의 경우는 [rslurm],\nPython의 경우는 [pyslurm]을 이용할 수 있는데, 자세한 내용은 각각 패키지 문서를 참고하라.\n\n\n"},{"fields":{"slug":"/docs/lab/seminar/2022/2022_UQinDL/","title":"A Review of Uncertainty Quantification in Deep Learning: Techniques, Applications and Challenges"},"frontmatter":{"draft":false},"rawBody":"#  A Review of Uncertainty Quantification in Deep Learning: Techniques, Applications and Challenges\n\nReview [\"A Review of Uncertainty Quantification in Deep Learning: Techniques, Applications and Challenges\"](https://arxiv.org/abs/2011.06225) with [Multivariate Statistics Laboratory](https://sites.google.com/view/mvstat)\n\n## 발표 자료\n\n* [section 1-3: 이경원](https://cloud.snubayes.duckdns.org:4443/s/WefNq9Wc2B6Caor)"}]}}}